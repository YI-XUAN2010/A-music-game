<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <!-- The page title will be set by JavaScript -->
    <title>ä¸€å€‹éŸ³æ¨‚éŠæˆ² (v1.1)</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&family=Noto+Sans+KR:wght@400;700&family=Noto+Sans+SC:wght@400;700&family=Noto+Sans+TC:wght@400;700&family=Poppins:wght@400;700&display=swap" rel="stylesheet">
    <!-- Scripts -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        body { 
            font-family: 'Poppins', 'Noto Sans TC', 'Noto Sans SC', 'Noto Sans JP', 'Noto Sans KR', sans-serif;
            background-color: #111827; 
            color: #e5e7eb; 
            margin: 0; 
            overflow: hidden; 
            -webkit-tap-highlight-color: transparent; 
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }
        .game-wrapper {
            background-color: #1f2937; 
            position: relative; 
            display: flex; 
            flex-direction: column; 
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            overflow: hidden;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }
        .game-header { width: 100%; display: flex; flex-direction: column; align-items: center; padding: 2.5rem 1rem 1rem 1rem; box-sizing: border-box; background: linear-gradient(to bottom, rgba(31, 41, 55, 0.9), transparent); }
        .stats-container { width: 100%; display: flex; justify-content: space-between; align-items: center; }
        .score-display, .combo-display { font-size: 1.5rem; font-weight: bold; text-shadow: 0 0 5px black; flex: 1; }
        .score-display { text-align: left; color: #f9fafb; }
        .combo-display { text-align: right; color: #f59e0b; transition: transform 0.1s ease; }
        .bpm-display { font-size: 1.2rem; color: #9ca3af; margin-top: 0.5rem; font-weight: bold; }
        #pauseButton { pointer-events: auto; background-color: #4b5563; color: white; border-radius: 0.375rem; padding: 0.5rem 1rem; font-weight: bold; transition: background-color 0.2s; flex-shrink: 0; }
        #pauseButton:hover { background-color: #6b7280; }
        #progressBarContainer { width: 90%; height: 8px; background-color: #4b5563; border-radius: 4px; overflow: hidden; margin-top: 1rem; }
        #progressBar { height: 100%; width: 0%; background-color: #a78bfa; transition: width 0.1s linear; }
        .hit-feedback { position: absolute; left: 50%; bottom: 35%; font-size: 2.5rem; font-weight: bold; text-shadow: 0 0 10px black; opacity: 0; transition: opacity 0.3s ease, transform 0.3s ease; transform: translate(-50%, 0) scale(0.8); }
        .hit-feedback.show { opacity: 1; transform: translate(-50%, -20px) scale(1); }
        .hit-feedback.perfect { color: #22c55e; } .hit-feedback.good { color: #eab308; } .hit-feedback.miss { color: #ef4444; }
        .game-footer { width: 100%; display: flex; height: 120px; pointer-events: auto; position: absolute; bottom: 40px; }
        .key-button { flex: 1; background-color: rgba(55, 65, 81, 0.5); border-top: 4px solid #4b5563; transition: background-color 0.1s, border-color 0.1s; display: flex; justify-content: center; align-items: center; color: #9ca3af; font-size: 2rem; font-weight: bold; }
        .key-button.active { background-color: rgba(200, 200, 255, 0.3); border-color: #a78bfa; }
        .key-label { transition: opacity 0.3s; }
        .screen-overlay, .pause-overlay, #countdownOverlay { position: absolute; inset: 0; background-color: rgba(0, 0, 0, 0.85); z-index: 20; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; color: white; padding: 2rem; box-sizing: border-box;}
        .screen-overlay.hidden, .pause-overlay.hidden, #countdownOverlay.hidden { display: none; }
        
        .scrollable-menu {
            justify-content: flex-start;
            overflow-y: auto;
        }
        .scrollable-menu .back-button {
            margin-bottom: 2rem;
            margin-top: auto;
        }
        .scrollable-menu > .song-selection {
             padding-top: 2rem;
        }

        .screen-overlay h1, .pause-overlay h1, .popup-menu h1 { font-size: 3rem; margin-bottom: 0.5rem; color: #d1d5db; }
        .screen-overlay p, .popup-menu p { font-size: 1.1rem; color: #9ca3af; margin-bottom: 1.5rem; }

        #countdownOverlay { font-size: 10rem; font-weight: bold; text-shadow: 0 0 20px black; background-color: transparent; z-index: 30;}
        #gameOverScreen .result-grid { display: grid; grid-template-columns: auto auto; justify-content: center; gap: 0.5rem 2rem; margin-bottom: 1rem; font-size: 1.2rem; }
        #gameOverScreen .result-label { text-align: right; color: #9ca3af; }
        #gameOverScreen .result-value { text-align: left; font-weight: bold; }
        #rankDisplay { font-size: 6rem; font-weight: bold; margin-bottom: 0rem; transition: color 0.3s; }
        #achievementDisplay { font-size: 2rem; font-weight: bold; margin-bottom: 1rem; height: 2rem; }
        .achievement-ap { color: #ef4444; } .achievement-fc { color: #22c55e; } 
        .rank-s { color: #a78bfa; } .rank-a { color: #eab308; } .rank-b { color: #3b82f6; } .rank-c { color: #f97316; } .rank-d { color: #6b7280; }
        .overlay-button { background-color: #a78bfa; color: white; font-size: 1.5rem; font-weight: bold; border: none; border-radius: 9999px; padding: 0.8rem 1rem; cursor: pointer; transition: background-color 0.2s, transform 0.1s; width: 100%; }
        .overlay-button:hover { background-color: #8b5cf6; }
        .overlay-button:active { transform: scale(0.95); }
        .overlay-button.secondary { background-color: #4b5563; }
        .overlay-button.secondary:hover { background-color: #6b7280; }
        .overlay-button.danger { background-color: #ef4444; }
        .overlay-button.danger:hover { background-color: #dc2626; }
        .overlay-button.locked { background-color: #374151; color: #6b7280; cursor: pointer; }
        .overlay-button.locked:hover { background-color: #4b5563; }
        
        .song-selection { display: flex; flex-direction: column; gap: 1rem; width: 100%; max-width: 380px; align-items: center;}
        .song-selection .overlay-button { margin-top: 0; }
        
        .main-setting-btn {
            height: 64px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1.2;
            padding: 0.5rem 1rem;
        }

        .setting-group {
            width: 100%;
            border: 1px solid #4b5563;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        .setting-group-title {
            color: #9ca3af;
            font-weight: bold;
            margin-bottom: 0.75rem;
            text-align: left;
        }
        .setting-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
        }


        textarea#saveDataKey { background-color: #374151; border: 1px solid #4b5563; color: white; width: 100%; margin-top: 1rem; padding: 0.5rem; border-radius: 0.25rem; }
        
        #playerScreen .player-stats-container { text-align: center; width:100%;}
        #playerScreen .player-stats { display: flex; flex-direction: column; align-items: center; gap: 0.5rem; width: 100%; }
        #playerScreen .stat-item { font-size: 1.2rem; }
        #playerScreen .stat-label { color: #9ca3af; }
        #playerScreen .stat-value { font-weight: bold; }
        #playerScreen .history-list { width: 100%; max-width: 380px; margin-top: 1.5rem; }
        #playerScreen details { background-color: rgba(55, 65, 81, 0.5); border-radius: 0.5rem; margin-bottom: 1rem; }
        #playerScreen summary { font-size: 1.25rem; font-weight: bold; padding: 1rem; cursor: pointer; list-style: none; }
        #playerScreen summary::-webkit-details-marker { display: none; }
        #playerScreen summary::after { content: ' â–¸'; float: right; transition: transform 0.2s; }
        #playerScreen details[open] summary::after { transform: rotate(90deg); }
        #playerScreen .history-details { padding: 0 1rem 1rem 1rem; }
        #playerScreen .history-entry { border-top: 1px solid #4b5563; padding-top: 1rem; margin-top: 1rem; }
        #playerScreen .history-entry:first-child { border-top: none; margin-top: 0; padding-top: 0; }
        #playerScreen .song-title { font-size: 1.1rem; font-weight: bold; }
        #playerScreen .song-stats { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.25rem 1rem; font-size: 0.9rem; margin-top: 0.5rem; }

        .xp-bar-container { width: 100%; background-color: #4b5563; border-radius: 9999px; overflow: hidden; height: 1.25rem; margin-top: 0.5rem;}
        .xp-bar { background-color: #a78bfa; height: 100%; width: 0%; transition: width 0.5s ease-out; text-align: center; color: white; font-size: 0.8rem; line-height: 1.25rem;}
        
        /* Corner Buttons for Main Menu */
        .bottom-corner-button {
            position: absolute;
            bottom: 1.5rem;
            width: 50px;
            height: 50px;
            background-color: #4b5563;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
            pointer-events: auto;
            z-index: 25;
            border: none;
        }
        .bottom-corner-button:hover {
            background-color: #6b7280;
        }
        #newsButton { left: 1.5rem; }
        #languageButton { right: 1.5rem; }

        /* News Screen specific styles */
        #newsScreen .news-content {
            background-color: #374151;
            padding: 1rem;
            border-radius: 0.5rem;
            text-align: left;
            white-space: pre-wrap;
            width: 100%;
            max-width: 380px;
        }
        
        /* Language Selection Screen */
        .language-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            width: 100%;
            max-width: 380px;
        }
        .language-grid .overlay-button {
            height: 80px;
        }
    </style>
</head>
<body>
    <div class="game-wrapper">
        <canvas id="gameCanvas"></canvas>
        <div class="ui-layer">
            <div class="game-header">
                <div class="stats-container">
                    <div id="scoreDisplay" class="score-display">0</div>
                    <button id="pauseButton" class="hidden" data-lang-key="pause">æš«åœ</button>
                    <div id="comboDisplay" class="combo-display"></div>
                </div>
                <div id="bpmDisplay" class="bpm-display hidden">BPM: 100</div>
                <div id="progressBarContainer">
                    <div id="progressBar"></div>
                </div>
            </div>
            <div id="hitFeedback" class="hit-feedback">PERFECT</div>
            <div class="game-footer">
                <div class="key-button" data-lane="0"><span class="key-label">A</span></div>
                <div class="key-button" data-lane="1"><span class="key-label">S</span></div>
                <div class="key-button" data-lane="2"><span class="key-label">D</span></div>
                <div class="key-button" data-lane="3"><span class="key-label">F</span></div>
            </div>
        </div>
        <div id="startScreen" class="screen-overlay">
            <div class="song-selection">
                <h1 data-lang-key="gameTitle">éŸ³ç¬¦é†¬</h1>
                <p data-lang-key="startScreenPrompt">ç‚ºäº†æœ€å¥½çš„éŠæˆ²é«”é©—ï¼Œè«‹é»æ“Šé–‹å§‹</p>
                <button id="startButton" class="overlay-button main-setting-btn" data-lang-key="clickToStart">é»æ“Šä»¥é–‹å§‹</button>
                <button id="startLanguageButton" class="overlay-button secondary" data-lang-key="languageTitle" style="height: auto; padding: 0.5rem 1rem; font-size: 1.1rem; margin-top: 1rem;"></button>
            </div>
        </div>
        <div id="mainMenu" class="screen-overlay scrollable-menu hidden">
            <div class="song-selection">
                <h1 data-lang-key="gameTitle">éŸ³ç¬¦é†¬</h1>
                <p data-lang-key="mainMenuPrompt">é¸æ“‡ä½ çš„éŠæˆ²æ¨¡å¼ï¼</p>
                <button id="classicModeButton" class="overlay-button main-setting-btn" data-lang-key="classicModeButton">ç¶“å…¸æ¼”å¥æ¨¡å¼</button>
                <button id="speedModeButton" class="overlay-button main-setting-btn" data-lang-key="speedModeButton">æ¥µé™æ‰‹é€Ÿæ¨¡å¼</button>
                <button id="otherButton" class="overlay-button secondary main-setting-btn" data-lang-key="otherButton">å…¶ä»–</button>
            </div>
            <!-- Corner Buttons -->
            <button id="newsButton" class="bottom-corner-button" title="News">ğŸ“°</button>
            <button id="languageButton" class="bottom-corner-button" title="Language">ğŸŒ</button>
        </div>
        <div id="newsScreen" class="screen-overlay hidden scrollable-menu">
            <div class="song-selection">
                <h1 data-lang-key="newsTitle"></h1>
                <p class="news-content" data-lang-key="newsContent"></p>
                <button class="overlay-button secondary back-button" data-target="mainMenu" data-lang-key="back" style="margin-top:2rem;"></button>
            </div>
        </div>
        <div id="otherMenu" class="screen-overlay hidden scrollable-menu">
            <div class="song-selection">
                <h1 style="padding-top: 2rem;" data-lang-key="otherTitle">å…¶ä»–</h1>
                <button id="playerButton" class="overlay-button main-setting-btn" data-lang-key="playerButton">ç©å®¶</button>
                <button id="saveDataButton" class="overlay-button main-setting-btn" data-lang-key="saveDataButton">å­˜æª”ç®¡ç†</button>
                <button id="modeMenuButton" class="overlay-button main-setting-btn" data-lang-key="modeMenuButton">éŠæˆ²æ¨¡å¼</button>
                <button id="vibrationMenuButton" class="overlay-button main-setting-btn" data-lang-key="vibrationMenuButton">éœ‡å‹•è¨­å®š</button>
                <button class="overlay-button secondary back-button main-setting-btn" data-target="mainMenu" data-lang-key="backToMain">è¿”å›ä¸»é¸å–®</button>
            </div>
        </div>
        <div id="languageMenu" class="screen-overlay hidden scrollable-menu">
            <div class="song-selection">
                <h1 data-lang-key="languageSelectionTitle"></h1>
                <div class="language-grid" id="languageGrid">
                    <!-- Language buttons will be populated by JS -->
                </div>
                <button id="languageBackBtn" class="overlay-button secondary back-button" data-target="mainMenu" data-lang-key="back" style="margin-top:2rem;"></button>
            </div>
        </div>
        <div id="modePopupMenu" class="screen-overlay hidden scrollable-menu">
            <div class="song-selection">
                <h1 data-lang-key="modeMenuTitle">éŠæˆ²æ¨¡å¼</h1>
                <p data-lang-key="modeMenuPrompt">é¸æ“‡é©åˆä½ çš„æ“ä½œæ–¹å¼</p>
                <div id="modeSelectionContainer" style="display: flex; gap: 1rem; justify-content: center; width:100%;">
                    <button id="touchModeBtn" class="overlay-button main-setting-btn" data-lang-key="touchMode">æ‰‹æ©Ÿè§¸æ§</button>
                    <button id="keyboardModeBtn" class="overlay-button secondary main-setting-btn" data-lang-key="keyboardMode">é›»è…¦éµç›¤</button>
                </div>
                <button class="overlay-button secondary back-button main-setting-btn" data-target="otherMenu" data-lang-key="back">è¿”å›</button>
            </div>
        </div>
        <div id="vibrationPopupMenu" class="screen-overlay hidden scrollable-menu">
            <div class="song-selection">
                <h1 data-lang-key="vibrationMenuTitle">éœ‡å‹•è¨­å®š</h1>
                <p data-lang-key="vibrationMenuPrompt">é¸æ“‡æ‚¨åå¥½çš„éœ‡å‹•æ¨¡å¼</p>
                <button class="overlay-button main-setting-btn" data-vibration="off" style="grid-column: 1 / -1;" data-lang-key="off">é—œé–‰</button>
                <div class="setting-group">
                    <div class="setting-group-title" data-lang-key="vibrationOnHit">åƒ…æ‰“æ“Šæ™‚</div>
                    <div class="setting-options">
                        <button class="overlay-button secondary" data-vibration="hit_weak" data-lang-key="weak">å¼±</button>
                        <button class="overlay-button secondary" data-vibration="hit_strong" data-lang-key="strong">å¼·</button>
                    </div>
                </div>
                <div class="setting-group">
                    <div class="setting-group-title" data-lang-key="vibrationFollowRhythm">è·Ÿéš¨ç¯€å¥</div>
                     <div class="setting-options">
                        <button class="overlay-button secondary" data-vibration="rhythm_weak" data-lang-key="weak">å¼±</button>
                        <button class="overlay-button secondary" data-vibration="rhythm_strong" data-lang-key="strong">å¼·</button>
                    </div>
                </div>
                <button id="vibrationHelpBtn" class="overlay-button secondary main-setting-btn" style="margin-top: 1rem;" data-lang-key="moreInfo">æ›´å¤šèªªæ˜</button>
                <button class="overlay-button secondary back-button main-setting-btn" data-target="otherMenu" data-lang-key="back">è¿”å›</button>
            </div>
        </div>
        <div id="classicMenu" class="screen-overlay hidden scrollable-menu">
            <div class="song-selection">
                <h1 data-lang-key="classicModeTitle">ç¶“å…¸æ¼”å¥æ¨¡å¼</h1>
                <p data-lang-key="classicModePrompt">é¸æ“‡ä¸€é¦–æ­Œæ›²é–‹å§‹æŒ‘æˆ°ï¼</p>
                <button class="overlay-button main-setting-btn" data-song="furElise"></button>
                <button class="overlay-button main-setting-btn" data-song="butterfly"></button>
                <button class="overlay-button main-setting-btn" data-song="twinkle"></button>
                <button class="overlay-button secondary back-button main-setting-btn" data-target="mainMenu" data-lang-key="backToMain">è¿”å›ä¸»é¸å–®</button>
            </div>
        </div>
        <div id="speedMenu" class="screen-overlay hidden scrollable-menu">
             <div class="song-selection">
                <h1 data-lang-key="speedModeTitle">æ¥µé™æ‰‹é€Ÿæ¨¡å¼</h1>
                <p data-lang-key="speedModePrompt">BPMå°‡æŒçºŒæå‡ï¼ŒæŒ‘æˆ°ä½ çš„æ¥µé™ï¼</p>
                <button class="overlay-button main-setting-btn" data-speed-mode="fixed" data-lang-key="speedFixed"></button>
                <button class="overlay-button main-setting-btn" data-speed-mode="random" data-lang-key="speedRandom"></button>
                <button class="overlay-button secondary back-button main-setting-btn" data-target="mainMenu" data-lang-key="backToMain">è¿”å›ä¸»é¸å–®</button>
            </div>
        </div>
        <div id="gameOverScreen" class="screen-overlay hidden">
            <h1 id="gameOverTitle">æ¼”å¥çµæŸ</h1>
            <div id="rankDisplayContainer">
                <div id="rankDisplay">S++</div>
                <div id="achievementDisplay"></div>
            </div>
            <div class="result-grid">
                <div class="result-label" data-lang-key="finalAccuracy">æœ€çµ‚ç²¾æº–åº¦ :</div><div id="finalAccuracy" class="result-value">0.00%</div>
                <div class="result-label" data-lang-key="finalScore">æœ€çµ‚åˆ†æ•¸ :</div><div id="finalScore" class="result-value">0</div>
                <div class="result-label">Perfect :</div><div id="perfectCount" class="result-value">0</div>
                <div class="result-label">Good :</div><div id="goodCount" class="result-value">0</div>
                <div class="result-label">Miss :</div><div id="missCount" class="result-value">0</div>
                <div class="result-label" data-lang-key="finalMaxCombo">æœ€é«˜ Combo :</div><div id="finalMaxCombo" class="result-value">0</div>
                <div class="result-label" id="finalBpmLabel" data-lang-key="finalBPM">æœ€é«˜ BPM :</div><div id="finalBPM" class="result-value">0</div>
                <div class="result-label" data-lang-key="expGained">ç²å¾—ç¶“é©— :</div><div id="expGained" class="result-value">0</div>
            </div>
            <button class="overlay-button home-button" data-target="mainMenu" data-lang-key="backToMain">å›åˆ°ä¸»é¸å–®</button>
        </div>
        <div id="saveDataScreen" class="screen-overlay hidden scrollable-menu">
            <div class="song-selection">
                <h1 data-lang-key="saveDataTitle">å­˜æª”ç®¡ç†</h1>
                <p data-lang-key="saveDataPrompt">è¤‡è£½é‡‘é‘°å‚™ä»½ï¼Œæˆ–è²¼ä¸Šé‡‘é‘°é‚„åŸç´€éŒ„ã€‚</p>
                <textarea id="saveDataKey" rows="4" readonly></textarea>
                <div style="display: flex; gap: 1rem; width: 100%;">
                    <button id="exportSaveData" class="overlay-button main-setting-btn" data-lang-key="exportKey">åŒ¯å‡ºé‡‘é‘°</button>
                    <button id="importSaveData" class="overlay-button secondary main-setting-btn" data-lang-key="importKey">åŒ¯å…¥é‡‘é‘°</button>
                </div>
                <button class="overlay-button secondary back-button main-setting-btn" data-target="otherMenu" data-lang-key="back">è¿”å›</button>
            </div>
        </div>
        <div id="playerScreen" class="screen-overlay hidden scrollable-menu">
             <div class="song-selection">
                <h1 style="padding-top: 2rem;" data-lang-key="playerTitle">ç©å®¶</h1>
                <div class="player-stats-container" id="playerStatsContainer" style="width: 100%;"></div>
                <div class="history-list" id="historyContent" style="width: 100%;"></div>
                <button class="overlay-button secondary back-button" data-target="otherMenu" style="margin-top: 2rem; margin-bottom: 2rem;" data-lang-key="back">è¿”å›</button>
            </div>
        </div>
        <div id="pauseOverlay" class="pause-overlay hidden">
            <div class="song-selection">
                <h1 data-lang-key="pauseTitle">éŠæˆ²æš«åœ</h1>
                <button id="resumeButton" class="overlay-button main-setting-btn" data-lang-key="resume">ç¹¼çºŒéŠæˆ²</button>
                <button id="modeSwitchButton" class="overlay-button secondary main-setting-btn"></button>
                <button id="pauseRestartButton" class="overlay-button main-setting-btn" data-lang-key="restart">é‡æ–°é–‹å§‹</button>
                <button id="exitButton" class="overlay-button danger main-setting-btn" data-lang-key="exit">é€€å‡ºéŠæˆ²</button>
            </div>
        </div>
        <div id="countdownOverlay" class="hidden">3</div>
    </div>

    <script>
    // --- I18N (Internationalization) ---
    const TRANSLATIONS = {
        en: {
            langName: "English",
            pageTitle: "A Music Game (v1.1)", gameTitle: "A Music Game", back: "Back", backToMain: "Main Menu", combo: "Combo", level: "Level {level}",
            startScreenPrompt: "For the best experience, please click to start.", clickToStart: "Click to Start", audioError: "Failed to start audio. Please check browser settings or refresh.",
            mainMenuPrompt: "Choose your game mode!", classicModeButton: "Classic Mode", speedModeButton: "Speed Mode", otherButton: "Other",
            otherTitle: "Other", languageTitle: "Language", playerButton: "Player", saveDataButton: "Save Data", modeMenuButton: "Game Mode", vibrationMenuButton: "Vibration",
            playerTitle: "Player", playerLevel: "Level:", playerExp: "EXP:", playerMaxLevel: "MAX LEVEL", classicHistory: "Classic Mode History", speedHistory: "Speed Mode History", highScore: "High Score:", highRank: "High Rank:", playCount: "Plays:", highCombo: "High Combo:", highBpm: "High BPM:",
            saveDataTitle: "Save Management", saveDataPrompt: "Copy the key to back up, or paste a key to restore.", exportKey: "Export Key", importKey: "Import Key", exportSuccess: "Key copied to clipboard!", exportFail: "Failed to copy. Please copy manually.", importPrompt: "Please paste your save key:", importSuccess: "Save data imported!", importFail: "Import failed! Key is invalid or corrupted.", importWarningOldKey: "This save key appears to be older than your current progress. Overwrite anyway?",
            modeMenuTitle: "Game Mode", modeMenuPrompt: "Choose your preferred control method.", touchMode: "Mobile (Touch)", keyboardMode: "PC (Keyboard)", switchToTouch: "Switch to Mobile Mode", switchToKeyboard: "Switch to PC Mode",
            vibrationMenuTitle: "Vibration", vibrationMenuPrompt: "Choose your preferred vibration mode.", vibrationOnHit: "On Hit Only", vibrationFollowRhythm: "Follow Rhythm", off: "Off", weak: "Weak", strong: "Strong", moreInfo: "More Info", vibrationHelp: "Mostly supported on Android.\nNot supported on iOS/iPadOS/Windows/macOS.\nPlease disable silent mode.", vibrationNotSupported: "Vibration (Not Supported)",
            classicModeTitle: "Classic Mode", classicModePrompt: "Choose a song to begin!",
            speedModeTitle: "Speed Mode", speedModePrompt: "BPM will continuously increase. Challenge your limits!", speedFixed: "Fixed Challenge", speedRandom: "Random Challenge",
            pause: "Pause", pauseTitle: "Paused", resume: "Resume", restart: "Restart", exit: "Exit Game", exitConfirm: "Are you sure you want to exit?",
            gameOverTitleClassic: "Performance End", gameOverTitleSpeed: "Challenge Over", finalAccuracy: "Accuracy:", finalScore: "Score:", finalMaxCombo: "Max Combo:", finalBPM: "Max BPM:", expGained: "EXP Gained:",
            allPerfect: "All Perfect", fullCombo: "Full Combo",
            levelUpAlert: "Congratulations! You are now Level {level}!", unlockSong: "Congratulations! Unlocked song: \"{songName}\"!", unlockCondition: "Unlock Condition", unlockLevelRequirement: "Requires Level {level} to unlock.",
            newsTitle: "Update v1.1", newsContent: "This version adds a news button, a language button, and more languages (Simplified Chinese, English, Japanese, Korean).", languageSelectionTitle: "Select Language",
        },
        zh: {
            langName: "ç¹é«”ä¸­æ–‡",
            pageTitle: "éŸ³ç¬¦é†¬ (v1.1)", gameTitle: "éŸ³ç¬¦é†¬", back: "è¿”å›", backToMain: "è¿”å›ä¸»é¸å–®", combo: "é€£æ“Š", level: "ç­‰ç´š {level}",
            startScreenPrompt: "ç‚ºäº†æœ€å¥½çš„éŠæˆ²é«”é©—ï¼Œè«‹é»æ“Šé–‹å§‹", clickToStart: "é»æ“Šä»¥é–‹å§‹", audioError: "ç„¡æ³•å•Ÿå‹•éŸ³è¨Šï¼Œè«‹æª¢æŸ¥ç€è¦½å™¨è¨­å®šæˆ–é‡æ•´ã€‚",
            mainMenuPrompt: "é¸æ“‡ä½ çš„éŠæˆ²æ¨¡å¼ï¼", classicModeButton: "ç¶“å…¸æ¼”å¥æ¨¡å¼", speedModeButton: "æ¥µé™æ‰‹é€Ÿæ¨¡å¼", otherButton: "å…¶ä»–",
            otherTitle: "å…¶ä»–", languageTitle: "èªè¨€", playerButton: "ç©å®¶", saveDataButton: "å­˜æª”ç®¡ç†", modeMenuButton: "éŠæˆ²æ¨¡å¼", vibrationMenuButton: "éœ‡å‹•è¨­å®š",
            playerTitle: "ç©å®¶", playerLevel: "ç­‰ç´š:", playerExp: "ç¶“é©—å€¼:", playerMaxLevel: "æ»¿ç­‰", classicHistory: "ç¶“å…¸æ¼”å¥æ¨¡å¼ç´€éŒ„", speedHistory: "æ¥µé™æ‰‹é€Ÿæ¨¡å¼ç´€éŒ„", highScore: "æœ€é«˜åˆ†:", highRank: "æœ€é«˜è©•ç´š:", playCount: "éŠç©æ¬¡æ•¸:", highCombo: "æœ€é«˜ Combo:", highBpm: "æœ€é«˜ BPM:",
            saveDataTitle: "å­˜æª”ç®¡ç†", saveDataPrompt: "è¤‡è£½é‡‘é‘°å‚™ä»½ï¼Œæˆ–è²¼ä¸Šé‡‘é‘°é‚„åŸç´€éŒ„ã€‚", exportKey: "åŒ¯å‡ºé‡‘é‘°", importKey: "åŒ¯å…¥é‡‘é‘°", exportSuccess: "é‡‘é‘°å·²è¤‡è£½åˆ°å‰ªè²¼ç°¿ï¼", exportFail: "è¤‡è£½å¤±æ•—ï¼Œè«‹æ‰‹å‹•è¤‡è£½ã€‚", importPrompt: "è«‹è²¼ä¸Šæ‚¨çš„å­˜æª”é‡‘é‘°ï¼š", importSuccess: "å­˜æª”åŒ¯å…¥æˆåŠŸï¼", importFail: "åŒ¯å…¥å¤±æ•—ï¼æ­¤é‡‘é‘°æå£æˆ–ç„¡æ•ˆã€‚", importWarningOldKey: "è©²é‡‘é‘°çš„ç´€éŒ„åèˆŠï¼Œæ˜¯å¦ä»è¦è¦†è“‹å­˜æª”ï¼Ÿ",
            modeMenuTitle: "éŠæˆ²æ¨¡å¼", modeMenuPrompt: "é¸æ“‡é©åˆä½ çš„æ“ä½œæ–¹å¼", touchMode: "æ‰‹æ©Ÿè§¸æ§", keyboardMode: "é›»è…¦éµç›¤", switchToTouch: "åˆ‡æ›ç‚ºæ‰‹æ©Ÿæ¨¡å¼", switchToKeyboard: "åˆ‡æ›ç‚ºé›»è…¦æ¨¡å¼",
            vibrationMenuTitle: "éœ‡å‹•è¨­å®š", vibrationMenuPrompt: "é¸æ“‡æ‚¨åå¥½çš„éœ‡å‹•æ¨¡å¼", vibrationOnHit: "åƒ…æ‰“æ“Šæ™‚", vibrationFollowRhythm: "è·Ÿéš¨ç¯€å¥", off: "é—œé–‰", weak: "å¼±", strong: "å¼·", moreInfo: "æ›´å¤šèªªæ˜", vibrationHelp: "Androidç³»çµ±å¤§éƒ¨åˆ†æ”¯æ´æ­¤æ¨¡å¼ã€‚\niOS/iPadOS/Windows/macOSä¸æ”¯æ´ã€‚\nè«‹é—œé–‰éœéŸ³æ¨¡å¼ã€‚", vibrationNotSupported: "éœ‡å‹•è¨­å®š (è£ç½®ä¸æ”¯æ´)",
            classicModeTitle: "ç¶“å…¸æ¼”å¥æ¨¡å¼", classicModePrompt: "é¸æ“‡ä¸€é¦–æ­Œæ›²é–‹å§‹æŒ‘æˆ°ï¼",
            speedModeTitle: "æ¥µé™æ‰‹é€Ÿæ¨¡å¼", speedModePrompt: "BPMå°‡æŒçºŒæå‡ï¼ŒæŒ‘æˆ°ä½ çš„æ¥µé™ï¼", speedFixed: "å®šé»æŒ‘æˆ°", speedRandom: "éš¨æ©ŸæŒ‘æˆ°",
            pause: "æš«åœ", pauseTitle: "éŠæˆ²æš«åœ", resume: "ç¹¼çºŒéŠæˆ²", restart: "é‡æ–°é–‹å§‹", exit: "é€€å‡ºéŠæˆ²", exitConfirm: "æ˜¯å¦é€€å‡ºéŠæˆ²ï¼Ÿ",
            gameOverTitleClassic: "æ¼”å¥çµæŸ", gameOverTitleSpeed: "æŒ‘æˆ°çµæŸ", finalAccuracy: "æœ€çµ‚ç²¾æº–åº¦:", finalScore: "æœ€çµ‚åˆ†æ•¸:", finalMaxCombo: "æœ€é«˜ Combo:", finalBPM: "æœ€é«˜ BPM:", expGained: "ç²å¾—ç¶“é©—:",
            allPerfect: "All Perfect", fullCombo: "Full Combo",
            levelUpAlert: "æ­å–œå‡ç´šï¼ä½ ç¾åœ¨æ˜¯ç­‰ç´š {level}ï¼", unlockSong: "æ­å–œï¼å·²è§£é–æ–°æ­Œæ›²ã€Œ{songName}ã€ï¼", unlockCondition: "è§£é–æ¢ä»¶", unlockLevelRequirement: "éœ€è¦é”åˆ°ç­‰ç´š {level} æ‰èƒ½è§£é–ã€‚",
            newsTitle: "æ›´æ–°ç‰ˆæœ¬ v1.1", newsContent: "è©²ç‰ˆæœ¬æ–°å¢äº†æ¶ˆæ¯éµã€èªè¨€éµå’Œæ›´å¤šèªè¨€ï¼ˆæ–°å¢äº†ç°¡é«”ä¸­æ–‡ã€è‹±æ–‡ã€æ—¥æ–‡ã€éŸ“æ–‡ï¼‰ã€‚", languageSelectionTitle: "é¸æ“‡èªè¨€",
        },
        'zh-CN': {
            langName: "ç®€ä½“ä¸­æ–‡",
            pageTitle: "éŸ³ç¬¦é…± (v1.1)", gameTitle: "éŸ³ç¬¦é…±", back: "è¿”å›", backToMain: "è¿”å›ä¸»èœå•", combo: "è¿å‡»", level: "ç­‰çº§ {level}",
            startScreenPrompt: "ä¸ºè·å¾—æœ€ä½³ä½“éªŒï¼Œè¯·ç‚¹å‡»å¼€å§‹", clickToStart: "ç‚¹å‡»ä»¥å¼€å§‹", audioError: "æ— æ³•å¯åŠ¨éŸ³é¢‘ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨è®¾ç½®æˆ–åˆ·æ–°ã€‚",
            mainMenuPrompt: "é€‰æ‹©ä½ çš„æ¸¸æˆæ¨¡å¼ï¼", classicModeButton: "ç»å…¸æ¼”å¥æ¨¡å¼", speedModeButton: "æé™æ‰‹é€Ÿæ¨¡å¼", otherButton: "å…¶ä»–",
            otherTitle: "å…¶ä»–", languageTitle: "è¯­è¨€", playerButton: "ç©å®¶", saveDataButton: "å­˜æ¡£ç®¡ç†", modeMenuButton: "æ¸¸æˆæ¨¡å¼", vibrationMenuButton: "æŒ¯åŠ¨è®¾ç½®",
            playerTitle: "ç©å®¶", playerLevel: "ç­‰çº§:", playerExp: "ç»éªŒå€¼:", playerMaxLevel: "æ»¡çº§", classicHistory: "ç»å…¸æ¨¡å¼è®°å½•", speedHistory: "æé™æ‰‹é€Ÿè®°å½•", highScore: "æœ€é«˜åˆ†:", highRank: "æœ€é«˜è¯„çº§:", playCount: "æ¸¸ç©æ¬¡æ•°:", highCombo: "æœ€é«˜è¿å‡»:", highBpm: "æœ€é«˜BPM:",
            saveDataTitle: "å­˜æ¡£ç®¡ç†", saveDataPrompt: "å¤åˆ¶å¯†é’¥å¤‡ä»½ï¼Œæˆ–ç²˜è´´å¯†é’¥è¿˜åŸã€‚", exportKey: "å¯¼å‡ºå¯†é’¥", importKey: "å¯¼å…¥å¯†é’¥", exportSuccess: "å¯†é’¥å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼", exportFail: "å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶ã€‚", importPrompt: "è¯·è¾“å…¥æ‚¨çš„å­˜æ¡£å¯†é’¥ï¼š", importSuccess: "å­˜æ¡£å¯¼å…¥æˆåŠŸï¼", importFail: "å¯¼å…¥å¤±è´¥ï¼å¯†é’¥æ— æ•ˆæˆ–æŸåã€‚", importWarningOldKey: "è¯¥å¯†é’¥çš„è®°å½•åæ—§ï¼Œæ˜¯å¦ä»è¦è¦†ç›–å­˜æ¡£ï¼Ÿ",
            modeMenuTitle: "æ¸¸æˆæ¨¡å¼", modeMenuPrompt: "é€‰æ‹©ä½ çš„æ“ä½œæ–¹å¼", touchMode: "æ‰‹æœºè§¦æ§", keyboardMode: "ç”µè„‘é”®ç›˜", switchToTouch: "åˆ‡æ¢ä¸ºæ‰‹æœºæ¨¡å¼", switchToKeyboard: "åˆ‡æ¢ä¸ºç”µè„‘æ¨¡å¼",
            vibrationMenuTitle: "æŒ¯åŠ¨è®¾ç½®", vibrationMenuPrompt: "é€‰æ‹©æ‚¨åå¥½çš„æŒ¯åŠ¨æ¨¡å¼", vibrationOnHit: "ä»…æ‰“å‡»æ—¶", vibrationFollowRhythm: "è·ŸéšèŠ‚å¥", off: "å…³é—­", weak: "å¼±", strong: "å¼º", moreInfo: "æ›´å¤šè¯´æ˜", vibrationHelp: "å®‰å“ç³»ç»Ÿå¤§å¤šæ”¯æŒæ­¤æ¨¡å¼ã€‚\niOS/iPadOS/Windows/macOSä¸æ”¯æŒã€‚\nè¯·å…³é—­é™éŸ³æ¨¡å¼ã€‚", vibrationNotSupported: "æŒ¯åŠ¨è®¾ç½® (è®¾å¤‡ä¸æ”¯æŒ)",
            classicModeTitle: "ç»å…¸æ¼”å¥æ¨¡å¼", classicModePrompt: "é€‰æ‹©ä¸€é¦–æ­Œæ›²å¼€å§‹æŒ‘æˆ˜ï¼",
            speedModeTitle: "æé™æ‰‹é€Ÿæ¨¡å¼", speedModePrompt: "BPMå°†æŒç»­æå‡ï¼ŒæŒ‘æˆ˜ä½ çš„æé™ï¼", speedFixed: "å®šç‚¹æŒ‘æˆ˜", speedRandom: "éšæœºæŒ‘æˆ˜",
            pause: "æš‚åœ", pauseTitle: "æ¸¸æˆæš‚åœ", resume: "ç»§ç»­æ¸¸æˆ", restart: "é‡æ–°å¼€å§‹", exit: "é€€å‡ºæ¸¸æˆ", exitConfirm: "ç¡®å®šé€€å‡ºå—ï¼Ÿ",
            gameOverTitleClassic: "æ¼”å¥ç»“æŸ", gameOverTitleSpeed: "æŒ‘æˆ˜ç»“æŸ", finalAccuracy: "æœ€ç»ˆå‡†ç¡®åº¦:", finalScore: "æœ€ç»ˆåˆ†æ•°:", finalMaxCombo: "æœ€é«˜è¿å‡»:", finalBPM: "æœ€é«˜BPM:", expGained: "è·å¾—ç»éªŒ:",
            allPerfect: "All Perfect", fullCombo: "Full Combo",
            levelUpAlert: "æ­å–œå‡çº§ï¼ä½ ç°åœ¨æ˜¯ç­‰çº§ {level}ï¼", unlockSong: "æ­å–œï¼å·²è§£é”æ–°æ­Œæ›²ã€Š{songName}ã€‹ï¼", unlockCondition: "è§£é”æ¡ä»¶", unlockLevelRequirement: "éœ€è¦è¾¾åˆ°ç­‰çº§ {level} æ‰èƒ½è§£é”ã€‚",
            newsTitle: "æ›´æ–°ç‰ˆæœ¬ v1.1", newsContent: "è¯¥ç‰ˆæœ¬æ–°å¢äº†æ¶ˆæ¯é”®ã€è¯­è¨€é”®å’Œæ›´å¤šè¯­è¨€ï¼ˆæ–°å¢äº†ç®€ä½“ä¸­æ–‡ã€è‹±æ–‡ã€æ—¥æ–‡ã€éŸ©æ–‡ï¼‰ã€‚", languageSelectionTitle: "é€‰æ‹©è¯­è¨€",
        },
        ja: {
            langName: "æ—¥æœ¬èª",
            pageTitle: "éŸ³æ¥½ã‚²ãƒ¼ãƒ  (v1.1)", gameTitle: "éŸ³æ¥½ã‚²ãƒ¼ãƒ ", back: "æˆ»ã‚‹", backToMain: "ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã¸", combo: "ã‚³ãƒ³ãƒœ", level: "ãƒ¬ãƒ™ãƒ« {level}",
            startScreenPrompt: "æœ€é«˜ã®ä½“é¨“ã®ãŸã‚ã«ã€ã‚¯ãƒªãƒƒã‚¯ã—ã¦é–‹å§‹ã—ã¦ãã ã•ã„ã€‚", clickToStart: "ã‚¯ãƒªãƒƒã‚¯ã—ã¦é–‹å§‹", audioError: "ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚’é–‹å§‹ã§ãã¾ã›ã‚“ã€‚ãƒ–ãƒ©ã‚¦ã‚¶ã®è¨­å®šã‚’ç¢ºèªã™ã‚‹ã‹ã€ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ã—ã¦ãã ã•ã„ã€‚",
            mainMenuPrompt: "ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ãã ã•ã„ï¼", classicModeButton: "ã‚¯ãƒ©ã‚·ãƒƒã‚¯ãƒ¢ãƒ¼ãƒ‰", speedModeButton: "ã‚¹ãƒ”ãƒ¼ãƒ‰ãƒ¢ãƒ¼ãƒ‰", otherButton: "ãã®ä»–",
            otherTitle: "ãã®ä»–", languageTitle: "è¨€èª", playerButton: "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼", saveDataButton: "ãƒ‡ãƒ¼ã‚¿ç®¡ç†", modeMenuButton: "ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰", vibrationMenuButton: "æŒ¯å‹•è¨­å®š",
            playerTitle: "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼", playerLevel: "ãƒ¬ãƒ™ãƒ«:", playerExp: "çµŒé¨“å€¤:", playerMaxLevel: "æœ€å¤§ãƒ¬ãƒ™ãƒ«", classicHistory: "ã‚¯ãƒ©ã‚·ãƒƒã‚¯ãƒ¢ãƒ¼ãƒ‰è¨˜éŒ²", speedHistory: "ã‚¹ãƒ”ãƒ¼ãƒ‰ãƒ¢ãƒ¼ãƒ‰è¨˜éŒ²", highScore: "ãƒã‚¤ã‚¹ã‚³ã‚¢:", highRank: "æœ€é«˜ãƒ©ãƒ³ã‚¯:", playCount: "ãƒ—ãƒ¬ã‚¤å›æ•°:", highCombo: "æœ€å¤§ã‚³ãƒ³ãƒœ:", highBpm: "æœ€å¤§BPM:",
            saveDataTitle: "ãƒ‡ãƒ¼ã‚¿ç®¡ç†", saveDataPrompt: "ã‚­ãƒ¼ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã™ã‚‹ã‹ã€ã‚­ãƒ¼ã‚’è²¼ã‚Šä»˜ã‘ã¦å¾©å…ƒã—ã¾ã™ã€‚", exportKey: "ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ", importKey: "ã‚¤ãƒ³ãƒãƒ¼ãƒˆ", exportSuccess: "ã‚­ãƒ¼ãŒã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã•ã‚Œã¾ã—ãŸï¼", exportFail: "ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸã€‚æ‰‹å‹•ã§ã‚³ãƒ”ãƒ¼ã—ã¦ãã ã•ã„ã€‚", importPrompt: "ã‚»ãƒ¼ãƒ–ã‚­ãƒ¼ã‚’è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„ï¼š", importSuccess: "ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚Œã¾ã—ãŸï¼", importFail: "ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸï¼ã‚­ãƒ¼ãŒç„¡åŠ¹ã‹ç ´æã—ã¦ã„ã¾ã™ã€‚", importWarningOldKey: "ã“ã®ã‚»ãƒ¼ãƒ–ã‚­ãƒ¼ã®è¨˜éŒ²ã¯ç¾åœ¨ã‚ˆã‚Šå¤ã„ã§ã™ã€‚ä¸Šæ›¸ãã—ã¾ã™ã‹ï¼Ÿ",
            modeMenuTitle: "ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰", modeMenuPrompt: "æ“ä½œæ–¹æ³•ã‚’é¸æŠã—ã¦ãã ã•ã„", touchMode: "ãƒ¢ãƒã‚¤ãƒ« (ã‚¿ãƒƒãƒ)", keyboardMode: "PC (ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰)", switchToTouch: "ãƒ¢ãƒã‚¤ãƒ«ãƒ¢ãƒ¼ãƒ‰ã«åˆ‡æ›¿", switchToKeyboard: "PCãƒ¢ãƒ¼ãƒ‰ã«åˆ‡æ›¿",
            vibrationMenuTitle: "æŒ¯å‹•è¨­å®š", vibrationMenuPrompt: "æŒ¯å‹•ãƒ¢ãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ãã ã•ã„", vibrationOnHit: "ãƒ’ãƒƒãƒˆæ™‚ã®ã¿", vibrationFollowRhythm: "ãƒªã‚ºãƒ ã«åˆã‚ã›ã‚‹", off: "ã‚ªãƒ•", weak: "å¼±", strong: "å¼·", moreInfo: "è©³ç´°", vibrationHelp: "ä¸»ã«Androidã§ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã™ã€‚\niOS/iPadOS/Windows/macOSã§ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚\nã‚µã‚¤ãƒ¬ãƒ³ãƒˆãƒ¢ãƒ¼ãƒ‰ã‚’ã‚ªãƒ•ã«ã—ã¦ãã ã•ã„ã€‚", vibrationNotSupported: "æŒ¯å‹• (éå¯¾å¿œ)",
            classicModeTitle: "ã‚¯ãƒ©ã‚·ãƒƒã‚¯ãƒ¢ãƒ¼ãƒ‰", classicModePrompt: "æ›²ã‚’é¸ã‚“ã§æŒ‘æˆ¦ã—ã‚ˆã†ï¼",
            speedModeTitle: "ã‚¹ãƒ”ãƒ¼ãƒ‰ãƒ¢ãƒ¼ãƒ‰", speedModePrompt: "BPMãŒä¸ŠãŒã‚Šç¶šã‘ã¾ã™ã€‚é™ç•Œã«æŒ‘æˆ¦ï¼", speedFixed: "å›ºå®šãƒãƒ£ãƒ¬ãƒ³ã‚¸", speedRandom: "ãƒ©ãƒ³ãƒ€ãƒ ãƒãƒ£ãƒ¬ãƒ³ã‚¸",
            pause: "ä¸€æ™‚åœæ­¢", pauseTitle: "ä¸€æ™‚åœæ­¢ä¸­", resume: "å†é–‹", restart: "ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ", exit: "çµ‚äº†", exitConfirm: "ã‚²ãƒ¼ãƒ ã‚’çµ‚äº†ã—ã¾ã™ã‹ï¼Ÿ",
            gameOverTitleClassic: "æ¼”å¥çµ‚äº†", gameOverTitleSpeed: "ãƒãƒ£ãƒ¬ãƒ³ã‚¸çµ‚äº†", finalAccuracy: "æœ€çµ‚ç²¾åº¦:", finalScore: "æœ€çµ‚ã‚¹ã‚³ã‚¢:", finalMaxCombo: "æœ€å¤§ã‚³ãƒ³ãƒœ:", finalBPM: "æœ€å¤§BPM:", expGained: "ç²å¾—çµŒé¨“å€¤:",
            allPerfect: "ã‚ªãƒ¼ãƒ«ãƒ‘ãƒ¼ãƒ•ã‚§ã‚¯ãƒˆ", fullCombo: "ãƒ•ãƒ«ã‚³ãƒ³ãƒœ",
            levelUpAlert: "ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ï¼ãƒ¬ãƒ™ãƒ« {level}ã«ãªã‚Šã¾ã—ãŸï¼", unlockSong: "ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼æ–°ã—ã„æ›²ã€Œ{songName}ã€ãŒã‚¢ãƒ³ãƒ­ãƒƒã‚¯ã•ã‚Œã¾ã—ãŸï¼", unlockCondition: "ã‚¢ãƒ³ãƒ­ãƒƒã‚¯æ¡ä»¶", unlockLevelRequirement: "ã‚¢ãƒ³ãƒ­ãƒƒã‚¯ã™ã‚‹ã«ã¯ãƒ¬ãƒ™ãƒ« {level} ãŒå¿…è¦ã§ã™ã€‚",
            newsTitle: "ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆ v1.1", newsContent: "ã“ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã¯ã€ãŠçŸ¥ã‚‰ã›ãƒœã‚¿ãƒ³ã€è¨€èªãƒœã‚¿ãƒ³ã€ãŠã‚ˆã³å¤šè¨€èªï¼ˆç°¡ä½“å­—ä¸­å›½èªã€è‹±èªã€æ—¥æœ¬èªã€éŸ“å›½èªï¼‰ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚", languageSelectionTitle: "è¨€èªã‚’é¸æŠ",
        },
        ko: {
            langName: "í•œêµ­ì–´",
            pageTitle: "ìŒì•… ê²Œì„ (v1.1)", gameTitle: "ìŒì•… ê²Œì„", back: "ë’¤ë¡œ", backToMain: "ë©”ì¸ ë©”ë‰´ë¡œ", combo: "ì½¤ë³´", level: "ë ˆë²¨ {level}",
            startScreenPrompt: "ìµœìƒì˜ ê²½í—˜ì„ ìœ„í•´ í´ë¦­í•˜ì—¬ ì‹œì‘í•˜ì„¸ìš”ã€‚", clickToStart: "í´ë¦­í•˜ì—¬ ì‹œì‘", audioError: "ì˜¤ë””ì˜¤ë¥¼ ì‹œì‘í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë¸Œë¼ìš°ì € ì„¤ì •ì„ í™•ì¸í•˜ê±°ë‚˜ ìƒˆë¡œê³ ì¹¨í•˜ì„¸ìš”.",
            mainMenuPrompt: "ê²Œì„ ëª¨ë“œë¥¼ ì„ íƒí•˜ì„¸ìš”!", classicModeButton: "í´ë˜ì‹ ëª¨ë“œ", speedModeButton: "ìŠ¤í”¼ë“œ ëª¨ë“œ", otherButton: "ê¸°íƒ€",
            otherTitle: "ê¸°íƒ€", languageTitle: "ì–¸ì–´", playerButton: "í”Œë ˆì´ì–´", saveDataButton: "ë°ì´í„° ê´€ë¦¬", modeMenuButton: "ê²Œì„ ëª¨ë“œ", vibrationMenuButton: "ì§„ë™ ì„¤ì •",
            playerTitle: "í”Œë ˆì´ì–´", playerLevel: "ë ˆë²¨:", playerExp: "ê²½í—˜ì¹˜:", playerMaxLevel: "ìµœëŒ€ ë ˆë²¨", classicHistory: "í´ë˜ì‹ ëª¨ë“œ ê¸°ë¡", speedHistory: "ìŠ¤í”¼ë“œ ëª¨ë“œ ê¸°ë¡", highScore: "ìµœê³  ì ìˆ˜:", highRank: "ìµœê³  ë“±ê¸‰:", playCount: "í”Œë ˆì´ íšŸìˆ˜:", highCombo: "ìµœëŒ€ ì½¤ë³´:", highBpm: "ìµœëŒ€ BPM:",
            saveDataTitle: "ë°ì´í„° ê´€ë¦¬", saveDataPrompt: "í‚¤ë¥¼ ë³µì‚¬í•˜ì—¬ ë°±ì—…í•˜ê±°ë‚˜, í‚¤ë¥¼ ë¶™ì—¬ë„£ì–´ ë³µì›í•˜ì„¸ìš”.", exportKey: "ë‚´ë³´ë‚´ê¸°", importKey: "ê°€ì ¸ì˜¤ê¸°", exportSuccess: "í‚¤ê°€ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!", exportFail: "ë³µì‚¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ìˆ˜ë™ìœ¼ë¡œ ë³µì‚¬í•´ì£¼ì„¸ìš”.", importPrompt: "ì„¸ì´ë¸Œ í‚¤ë¥¼ ë¶™ì—¬ë„£ìœ¼ì„¸ìš”:", importSuccess: "ë°ì´í„°ë¥¼ ì„±ê³µì ìœ¼ë¡œ ê°€ì ¸ì™”ìŠµë‹ˆë‹¤!", importFail: "ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨! í‚¤ê°€ ìœ íš¨í•˜ì§€ ì•Šê±°ë‚˜ ì†ìƒë˜ì—ˆìŠµë‹ˆë‹¤ã€‚", importWarningOldKey: "ì´ ì„¸ì´ë¸Œ í‚¤ì˜ ê¸°ë¡ì´ í˜„ì¬ ì§„í–‰ ìƒí™©ë³´ë‹¤ ì˜¤ë˜ë˜ì—ˆìŠµë‹ˆë‹¤. ë®ì–´ì“°ì‹œê² ìŠµë‹ˆê¹Œ?",
            modeMenuTitle: "ê²Œì„ ëª¨ë“œ", modeMenuPrompt: "ì„ í˜¸í•˜ëŠ” ì¡°ì‘ ë°©ì‹ì„ ì„ íƒí•˜ì„¸ìš”.", touchMode: "ëª¨ë°”ì¼ (í„°ì¹˜)", keyboardMode: "PC (í‚¤ë³´ë“œ)", switchToTouch: "ëª¨ë°”ì¼ ëª¨ë“œë¡œ ì „í™˜", switchToKeyboard: "PC ëª¨ë“œë¡œ ì „í™˜",
            vibrationMenuTitle: "ì§„ë™ ì„¤ì •", vibrationMenuPrompt: "ì„ í˜¸í•˜ëŠ” ì§„ë™ ëª¨ë“œë¥¼ ì„ íƒí•˜ì„¸ìš”.", vibrationOnHit: "íˆíŠ¸ ì‹œì—ë§Œ", vibrationFollowRhythm: "ë¦¬ë“¬ì— ë§ì¶°", off: "ë„ê¸°", weak: "ì•½í•˜ê²Œ", strong: "ê°•í•˜ê²Œ", moreInfo: "ì¶”ê°€ ì •ë³´", vibrationHelp: "ì£¼ë¡œ ì•ˆë“œë¡œì´ë“œì—ì„œ ì§€ì›ë©ë‹ˆë‹¤.\niOS/iPadOS/Windows/macOSì—ì„œëŠ” ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\në¬´ìŒ ëª¨ë“œë¥¼ ë¹„í™œì„±í™”í•˜ì„¸ìš”ã€‚", vibrationNotSupported: "ì§„ë™ (ë¯¸ì§€ì›)",
            classicModeTitle: "í´ë˜ì‹ ëª¨ë“œ", classicModePrompt: "ë„ì „í•  ê³¡ì„ ì„ íƒí•˜ì„¸ìš”!",
            speedModeTitle: "ìŠ¤í”¼ë“œ ëª¨ë“œ", speedModePrompt: "BPMì´ ê³„ì† ì¦ê°€í•©ë‹ˆë‹¤. í•œê³„ì— ë„ì „í•˜ì„¸ìš”!", speedFixed: "ê³ ì • ì±Œë¦°ì§€", speedRandom: "ëœë¤ ì±Œë¦°ì§€",
            pause: "ì¼ì‹œì •ì§€", pauseTitle: "ì¼ì‹œì •ì§€ë¨", resume: "ê³„ì†í•˜ê¸°", restart: "ë‹¤ì‹œ ì‹œì‘", exit: "ë‚˜ê°€ê¸°", exitConfirm: "ê²Œì„ì„ ì¢…ë£Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
            gameOverTitleClassic: "ì—°ì£¼ ì¢…ë£Œ", gameOverTitleSpeed: "ë„ì „ ì¢…ë£Œ", finalAccuracy: "ìµœì¢… ì •í™•ë„:", finalScore: "ìµœì¢… ì ìˆ˜:", finalMaxCombo: "ìµœëŒ€ ì½¤ë³´:", finalBPM: "ìµœëŒ€ BPM:", expGained: "íšë“ ê²½í—˜ì¹˜:",
            allPerfect: "ì˜¬ í¼í™íŠ¸", fullCombo: "í’€ ì½¤ë³´",
            levelUpAlert: "ë ˆë²¨ ì—…! ì´ì œ ë ˆë²¨ {level}ì…ë‹ˆë‹¤!", unlockSong: "ì¶•í•˜í•©ë‹ˆë‹¤! ìƒˆë¡œìš´ ê³¡ '{songName}'ì´ ì ê¸ˆ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤!", unlockCondition: "ì ê¸ˆ í•´ì œ ì¡°ê±´", unlockLevelRequirement: "ì ê¸ˆì„ í•´ì œí•˜ë ¤ë©´ ë ˆë²¨ {level}ì´ í•„ìš”í•©ë‹ˆë‹¤ã€‚",
            newsTitle: "ì—…ë°ì´íŠ¸ v1.1", newsContent: "ì´ ë²„ì „ì—ëŠ” ë‰´ìŠ¤ ë²„íŠ¼, ì–¸ì–´ ë²„íŠ¼ ë° ë” ë§ì€ ì–¸ì–´(ì¤‘êµ­ì–´ ê°„ì²´, ì˜ì–´, ì¼ë³¸ì–´, í•œêµ­ì–´)ê°€ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.", languageSelectionTitle: "ì–¸ì–´ ì„ íƒ",
        }
    };
    
    // --- Constants and Game Data ---
    const CONSTANTS = {
        LANE_COUNT: 4,
        FALL_TIME_SECONDS: 1.8,
        HIT_LINE_Y_RATIO: 0.7,
        PERFECT_THRESHOLD: 0.08,
        GOOD_THRESHOLD: 0.16,
        LANE_COLORS: ['#f87171', '#fb923c', '#a78bfa', '#60a5fa'],
        RANK_ORDER: ['D', 'C-', 'C', 'C+', 'B-', 'B', 'B+', 'A-', 'A', 'A+', 'S-', 'S', 'S+', 'S++'],
        PLAYER_DATA_KEY: 'noteSaucePlayerData_v2',
        CURRENT_VERSION: 3,
        MAX_LEVEL: 6,
    };

    const SONG_LIBRARY = {
        twinkle: { 
            name: { en: "Twinkle Twinkle", zh: "å°æ˜Ÿæ˜Ÿ", 'zh-CN': 'å°æ˜Ÿæ˜Ÿ', ja: 'ãã‚‰ãã‚‰æ˜Ÿ', ko: 'ë°˜ì§ë°˜ì§ ì‘ì€ ë³„' }, 
            bpm: 100, 
            beatmap: [ [1,0,"C4"], [2,0,"C4"], [3,2,"G4"], [4,2,"G4"], [5,2,"A4"], [6,2,"A4"], [7,2,"G4"], [9,1,"F4"], [10,1,"F4"], [11,1,"E4"], [12,1,"E4"], [13,0,"D4"], [14,0,"D4"], [15,0,"C4"], [17,2,"G4"], [18,2,"G4"], [19,1,"F4"], [20,1,"F4"], [21,1,"E4"], [22,1,"E4"], [23,0,"D4"], [25,2,"G4"], [26,2,"G4"], [27,1,"F4"], [28,1,"F4"], [29,1,"E4"], [30,1,"E4"], [31,0,"D4"], [33,0,"C4"], [34,0,"C4"], [35,2,"G4"], [36,2,"G4"], [37,2,"A4"], [38,2,"A4"], [39,2,"G4"], [41,1,"F4"], [42,1,"F4"], [43,1,"E4"], [44,1,"E4"], [45,0,"D4"], [46,0,"D4"], [47,0,"C4"], ] 
        },
        butterfly: { 
            name: { en: "Butterfly", zh: "è´è¶", 'zh-CN': 'è´è¶', ja: 'è¶ã€…', ko: 'ë‚˜ë¹„' }, 
            unlockLevel: 2, // <-- Changed from 3 to 2
            bpm: 100, 
            beatmap: [ [1.0, 0, "C4"], [2.0, 0, "C4"], [2.5, 0, "D4"], [3.0, 1, "E4"], [4.0, 1, "E4"], [5.0, 0, "D4"], [5.5, 0, "C4"], [6.0, 0, "D4"], [6.5, 1, "E4"], [7.0, 0, "C4"], [9.0, 1, "E4"], [10.0, 1, "F4"], [11.0, 2, "G4"], [12.0, 2, "G4"], [13.0, 1, "F4"], [13.5, 1, "E4"], [14.0, 1, "F4"], [14.5, 2, "G4"], [15.0, 1, "E4"], [17.0, 0, "C5"], [18.0, 3, "B4"], [19.0, 2, "A4"], [20.0, 2, "G4"], [21.0, 1, "E4"], [22.0, 0, "C5"], [23.0, 3, "B4"], [24.0, 2, "A4"], [25.0, 2, "G4"], [26.0, 2, "A4"], [27.0, 3, "B4"], [28.0, 0, "C5"], [29.0, 2, "G4"], [31.0, 1, "E4"] ] 
        },
        furElise: { 
            name: { en: "For Elise", zh: "çµ¦æ„›éº—çµ²", 'zh-CN': 'è‡´çˆ±ä¸½ä¸', ja: 'ã‚¨ãƒªãƒ¼ã‚¼ã®ãŸã‚ã«', ko: 'ì—˜ë¦¬ì œë¥¼ ìœ„í•˜ì—¬' }, 
            unlockLevel: 6,
            bpm: 120, 
            beatmap: [ [1.0, 3, "E5"], [1.5, 2, "Ds5"], [2.0, 3, "E5"], [2.5, 2, "Ds5"], [3.0, 3, "E5"], [3.5, 1, "B4"], [4.0, 2, "D5"], [4.5, 0, "C5"], [5.0, 2, "A4"], [5.0, 0, "A3"], [6.0, 0, "C4"], [6.5, 1, "E4"], [7.0, 2, "A4"], [7.5, 1, "B4"], [7.5, 0, "E3"], [9.0, 1, "E4"], [9.0, 0, "G3"], [9.5, 2, "Gs4"], [10.0, 3, "B4"], [10.5, 0, "C5"], [10.5, 0, "A3"], [11.5, 3, "E5"], [12.0, 2, "Ds5"], [12.5, 3, "E5"], [13.0, 2, "Ds5"], [13.5, 3, "E5"], [14.0, 1, "B4"], [14.5, 2, "D5"], [15.0, 0, "C5"], [15.5, 2, "A4"], [15.5, 0, "A3"], [17.0, 0, "C4"], [17.5, 1, "E4"], [18.0, 2, "A4"], [18.5, 1, "B4"], [18.5, 0, "E3"], [20.0, 1, "E4"], [20.0, 0, "G3"], [20.5, 0, "C5"], [21.0, 3, "B4"], [21.5, 2, "A4"], [21.5, 0, "A2"], [23.0, 3, "E5"], [23.5, 2, "Ds5"], [24.0, 3, "E5"], [24.5, 2, "Ds5"], [25.0, 3, "E5"], [25.5, 1, "B4"], [26.0, 2, "D5"], [26.5, 0, "C5"], [27.0, 2, "A4"], [27.0, 0, "A3"], [28.0, 0, "C4"], [28.5, 1, "E4"], [29.0, 2, "A4"], [29.5, 1, "B4"], [29.5, 0, "E3"], [31.0, 0, "C5"], [31.5, 2, "G4"], [32.0, 1, "F4"], [32.5, 3, "E5"], [32.5, 1, "E4"], [33.5, 2, "D5"], [34.0, 1, "C5"], [34.5, 2, "B4"], [34.5, 0, "G3"], [35.5, 2, "E4"], [36.0, 3, "E5"], [36.5, 2, "E4"], [37.0, 3, "E5"], [37.5, 2, "Ds5"]]}
    };

    const SPEED_MODE_CONFIG = {
        fixed: { unlockLevel: 4 },
        random: { unlockLevel: 5 },
    };

    /**
     * LanguageManager: Handles all language-related tasks
     */
    class LanguageManager {
        constructor(gameInstance) {
            this.game = gameInstance;
            this.currentLanguage = 'zh'; // Default language
        }

        init() {
            const savedLang = this.game.playerData.playerData.language;
            const browserLangMatch = navigator.language;
            let defaultLang = 'en';
            if (browserLangMatch.startsWith('zh-CN')) defaultLang = 'zh-CN';
            else if (browserLangMatch.startsWith('zh')) defaultLang = 'zh';
            else if (browserLangMatch.startsWith('ja')) defaultLang = 'ja';
            else if (browserLangMatch.startsWith('ko')) defaultLang = 'ko';

            this.setLanguage(savedLang || defaultLang, false);
            this.populateLanguageMenu();
        }
        
        populateLanguageMenu() {
            const grid = document.getElementById('languageGrid');
            grid.innerHTML = ''; // Clear existing
            Object.keys(TRANSLATIONS).forEach(langCode => {
                const langName = TRANSLATIONS[langCode].langName;
                const button = document.createElement('button');
                button.className = 'overlay-button';
                button.dataset.lang = langCode;
                button.textContent = langName;
                button.onclick = () => {
                    this.setLanguage(langCode);
                    // Stay on the language screen
                };
                grid.appendChild(button);
            });
        }


        get(key, replacements = {}) {
            const langMap = TRANSLATIONS[this.currentLanguage] || TRANSLATIONS.en;
            let text = langMap[key] || TRANSLATIONS.en[key] || `[${key}]`;
            for (const placeholder in replacements) {
                text = text.replace(`{${placeholder}}`, replacements[placeholder]);
            }
            return text;
        }

        setLanguage(lang, fromUserAction = true) {
            this.currentLanguage = lang;
            document.documentElement.lang = lang;
            
            if (fromUserAction) {
                this.game.playerData.playerData.language = lang;
                this.game.playerData.save();
            }

            this.updateUI();
        }

        updateUI() {
            document.querySelectorAll('[data-lang-key]').forEach(el => {
                const key = el.dataset.langKey;
                el.textContent = this.get(key);
            });
            document.title = this.get('pageTitle');
            this.game.ui.updateAllUnlocks(this.game.playerData.playerData);
            this.game.ui.updateKeyLabels(this.game.inputMode);
            this.game.ui.displayPlayerPage(this.game.playerData.playerData);

            document.querySelectorAll('#languageGrid button').forEach(button => {
                 button.classList.toggle('secondary', button.dataset.lang !== this.currentLanguage);
            });
            
            if (!this.game.supportsVibration) {
                 this.game.ui.dom.vibrationMenuButton.textContent = this.get('vibrationNotSupported');
            }
        }
    }
    
    /**
     * AudioManager: Manages all audio-related tasks using Tone.js
     */
    class AudioManager {
        constructor() {
            this.hitSynth = null;
            this.metronomeEvent = null;
            this.isReady = false;
        }

        async init() {
            if (this.isReady) return;
            await Tone.start();
            this.hitSynth = new Tone.Synth({ oscillator: { type: 'square' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination();
            this.isReady = true;
            console.log("AudioContext is ready.");
        }

        playNote(pitch) {
            if (!this.isReady || !pitch) return;
            this.hitSynth.triggerAttackRelease(pitch, '8n', Tone.now());
        }

        startTransport(bpm, vibrationCallback) {
            if (!this.isReady) return;
            Tone.Transport.bpm.value = bpm;
            if (vibrationCallback) {
                this.metronomeEvent = Tone.Transport.scheduleRepeat(() => {
                    vibrationCallback();
                }, '4n');
            }
            Tone.Transport.position = 0;
            Tone.Transport.start();
        }

        stopAndReset() {
            Tone.Transport.stop();
            Tone.Transport.cancel(0);
            if (this.metronomeEvent) {
                this.metronomeEvent.dispose();
                this.metronomeEvent = null;
            }
        }
        
        pause() { Tone.Transport.pause(); }
        resume() { Tone.Transport.start(); }

        getCurrentTime() { return this.isReady ? Tone.Transport.seconds : 0; }
        
        setBPM(bpm) { if(this.isReady) Tone.Transport.bpm.value = bpm; }
    }

    /**
     * UIManager: Handles all DOM manipulations and rendering
     */
    class UIManager {
        constructor(gameInstance) {
            this.game = gameInstance;
            this.ctx = null;
            this.dom = {};
            this.laneWidth = 0;
            this.hitLineY = 0;
            this.feedbackTimeout = null;
        }
        
        init() {
            this.cacheDOMElements();
            this.ctx = this.dom.gameCanvas.getContext('2d');
        }

        cacheDOMElements() {
            const ids = [
                'gameCanvas', 'scoreDisplay', 'comboDisplay', 'bpmDisplay', 'hitFeedback', 'startScreen', 'mainMenu', 'classicMenu', 
                'speedMenu', 'otherMenu', 'languageMenu', 'newsScreen', 'modePopupMenu', 'vibrationPopupMenu', 'playerScreen', 'saveDataScreen', 'gameOverScreen', 'pauseOverlay', 
                'countdownOverlay', 'progressBar', 'progressBarContainer', 'pauseButton', 'startButton', 'classicModeButton', 
                'speedModeButton', 'otherButton', 'playerButton', 'saveDataButton', 'modeMenuButton', 'vibrationMenuButton', 
                'vibrationHelpBtn', 'touchModeBtn', 'keyboardModeBtn', 'resumeButton', 'modeSwitchButton', 'pauseRestartButton', 
                'exitButton', 'saveDataKey', 'exportSaveData', 'importSaveData', 'playerStatsContainer', 'historyContent', 
                'gameOverTitle', 'rankDisplayContainer', 'rankDisplay', 'achievementDisplay', 'finalAccuracy', 'finalScore', 
                'perfectCount', 'goodCount', 'missCount', 'finalMaxCombo', 'finalBpmLabel', 'finalBPM', 'expGained',
                'languageButton', 'newsButton', 'startLanguageButton', 'languageBackBtn'
            ];
            
            ids.forEach(id => this.dom[id] = document.getElementById(id));
            
            this.dom.keyButtons = document.querySelectorAll('.key-button');
            this.dom.keyLabels = document.querySelectorAll('.key-label');
            this.dom.vibrationButtons = document.querySelectorAll('[data-vibration]');
            this.dom.backButtons = document.querySelectorAll('.back-button');
            this.dom.homeButtons = document.querySelectorAll('.home-button');
            this.dom.classicSongButtons = document.querySelectorAll('#classicMenu [data-song]');
            this.dom.speedModeButtons = document.querySelectorAll('#speedMenu [data-speed-mode]');
        }

        resize(wrapper) {
            const TARGET_RATIO = 9 / 16;
            const availableWidth = window.innerWidth;
            const availableHeight = window.innerHeight;
            const windowRatio = availableWidth / availableHeight;
            let newWidth, newHeight;
            if (windowRatio > TARGET_RATIO) {
                newHeight = availableHeight;
                newWidth = newHeight * TARGET_RATIO;
            } else {
                newWidth = availableWidth;
                newHeight = newWidth / TARGET_RATIO;
            }
            wrapper.style.width = `${newWidth}px`;
            wrapper.style.height = `${newHeight}px`;
            this.dom.gameCanvas.width = newWidth;
            this.dom.gameCanvas.height = newHeight;
            this.laneWidth = this.dom.gameCanvas.width / CONSTANTS.LANE_COUNT;
            this.hitLineY = this.dom.gameCanvas.height * CONSTANTS.HIT_LINE_Y_RATIO;
        }
        
        showScreen(screenName) {
            ['startScreen', 'mainMenu', 'classicMenu', 'speedMenu', 'otherMenu', 'languageMenu', 'newsScreen', 'modePopupMenu', 
             'vibrationPopupMenu', 'playerScreen', 'saveDataScreen', 'gameOverScreen', 'pauseOverlay', 'countdownOverlay']
            .forEach(name => {
                if(this.dom[name]) this.dom[name].classList.add('hidden');
            });
            if (this.dom[screenName]) {
                this.dom[screenName].classList.remove('hidden');
                if (screenName === 'playerScreen') {
                    this.displayPlayerPage(this.game.playerData.playerData);
                }
            }
        }
        
        updateInGameUI(stats) {
            this.dom.scoreDisplay.textContent = stats.score;
            this.dom.comboDisplay.textContent = stats.combo > 1 ? `${this.game.lang.get('combo')} ${stats.combo}` : '';
            if (stats.combo > 1) {
                this.dom.comboDisplay.style.transform = 'scale(1.2)';
                setTimeout(() => this.dom.comboDisplay.style.transform = 'scale(1)', 100);
            }
            if(stats.bpm) {
                this.dom.bpmDisplay.classList.remove('hidden');
                this.dom.bpmDisplay.textContent = `BPM: ${Math.floor(stats.bpm)}`;
            } else {
                this.dom.bpmDisplay.classList.add('hidden');
            }
            this.dom.progressBar.style.width = `${stats.progress * 100}%`;
            this.dom.progressBarContainer.style.display = stats.showProgressBar ? 'block' : 'none';
            this.dom.pauseButton.classList.toggle('hidden', !stats.showPause);
        }

        resetInGameUI() {
            this.updateInGameUI({ score: 0, combo: 0, progress: 0, showPause: false, showProgressBar: false});
        }

        showHitFeedback(type) {
            const textMap = { perfect: 'PERFECT', good: 'GOOD', miss: 'MISS' };
            this.dom.hitFeedback.textContent = textMap[type];
            this.dom.hitFeedback.className = `hit-feedback show ${type}`;
            if (this.feedbackTimeout) clearTimeout(this.feedbackTimeout);
            this.feedbackTimeout = setTimeout(() => this.dom.hitFeedback.classList.remove('show'), 300);
        }
        
        draw(notes) {
            this.ctx.clearRect(0, 0, this.dom.gameCanvas.width, this.dom.gameCanvas.height);
            for (let i = 0; i < CONSTANTS.LANE_COUNT; i++) {
                this.ctx.fillStyle = (i % 2 === 0) ? '#1f2937' : '#374151';
                this.ctx.fillRect(i * this.laneWidth, 0, this.laneWidth, this.dom.gameCanvas.height);
            }
            this.ctx.fillStyle = '#a78bfa';
            this.ctx.fillRect(0, this.hitLineY - 2, this.dom.gameCanvas.width, 4);
            for (const note of notes) {
                if (note.y > -50 && note.y < this.dom.gameCanvas.height + 50) {
                    this.ctx.fillStyle = CONSTANTS.LANE_COLORS[note.lane];
                    this.ctx.fillRect(note.lane * this.laneWidth + 5, note.y - 10, this.laneWidth - 10, 20);
                }
            }
        }
        
        showCountdown(count, callback) {
            this.showScreen('countdownOverlay');
            this.dom.countdownOverlay.textContent = count;
            const interval = setInterval(() => {
                count--;
                if (count > 0) {
                    this.dom.countdownOverlay.textContent = count;
                } else {
                    clearInterval(interval);
                    this.showScreen('none');
                    callback();
                }
            }, 1000);
        }
        
        showGameOver(results) {
            this.dom.gameOverTitle.textContent = results.title;
            this.dom.finalAccuracy.textContent = `${results.accuracy.toFixed(2)}%`;
            this.dom.finalScore.textContent = results.score;
            this.dom.perfectCount.textContent = results.counts.perfect;
            this.dom.goodCount.textContent = results.counts.good;
            this.dom.missCount.textContent = results.counts.miss;
            this.dom.finalMaxCombo.textContent = results.maxCombo;
            this.dom.expGained.textContent = `+${results.expGained}`;
            
            this.dom.rankDisplayContainer.style.display = results.rank ? 'block' : 'none';
            if(results.rank) {
                this.dom.rankDisplay.textContent = results.rank;
                let rankClass = 'rank-d';
                if (results.rank.startsWith('S')) rankClass = 'rank-s'; else if (results.rank.startsWith('A')) rankClass = 'rank-a'; else if (results.rank.startsWith('B')) rankClass = 'rank-b'; else if (results.rank.startsWith('C')) rankClass = 'rank-c';
                this.dom.rankDisplay.className = rankClass;
            }
            
            this.dom.achievementDisplay.textContent = results.achievement.text;
            this.dom.achievementDisplay.className = results.achievement.class;
            
            this.dom.finalBpmLabel.style.display = results.maxBPM ? 'block' : 'none';
            this.dom.finalBPM.style.display = results.maxBPM ? 'block' : 'none';
            if (results.maxBPM) {
                this.dom.finalBPM.textContent = results.maxBPM;
            }
            
            this.showScreen('gameOverScreen');
        }

        updateKeyLabels(mode) {
            this.dom.keyLabels.forEach(label => label.style.opacity = (mode === 'keyboard') ? '1' : '0');
            const switchKey = (mode === 'keyboard') ? 'switchToTouch' : 'switchToKeyboard';
            this.dom.modeSwitchButton.textContent = this.game.lang.get(switchKey);
        }

        updateVibrationButtons(vibrationMode) {
             this.dom.vibrationButtons.forEach(btn => {
                btn.classList.toggle('secondary', btn.dataset.vibration !== vibrationMode);
            });
        }
        
        updateModeButtons(inputMode) {
            this.dom.touchModeBtn.classList.toggle('secondary', inputMode !== 'touch');
            this.dom.keyboardModeBtn.classList.toggle('secondary', inputMode !== 'keyboard');
        }
        
        updateAllUnlocks(playerData) {
            const lang = this.game.lang;
            const currentLang = lang.currentLanguage;

            const setupButton = (button, isUnlocked, unlockLevel, startFn) => {
                const newButton = button.cloneNode(true);
                button.parentNode.replaceChild(newButton, button);

                newButton.classList.toggle('locked', !isUnlocked);
                
                if (isUnlocked) {
                    newButton.addEventListener('click', startFn);
                } else {
                    newButton.addEventListener('click', (e) => {
                        e.preventDefault();
                        if (unlockLevel) {
                            alert(lang.get('unlockLevelRequirement', { level: unlockLevel }));
                        }
                    });
                }
                return newButton;
            };

            this.dom.classicSongButtons = document.querySelectorAll('#classicMenu [data-song]');
            this.dom.classicSongButtons.forEach(button => {
                const songId = button.dataset.song;
                const songData = playerData.songs[songId];
                const songInfo = SONG_LIBRARY[songId];
                const isUnlocked = songData.unlocked;
                
                let buttonText = songInfo.name[currentLang];
                if (!isUnlocked && songInfo.unlockLevel) {
                    buttonText += ` (${lang.get('level', { level: songInfo.unlockLevel })})`;
                }
                button.textContent = buttonText;
                
                setupButton(button, isUnlocked, songInfo.unlockLevel, () => this.game.startClassicGame(songId));
            });

            this.dom.speedModeButtons = document.querySelectorAll('#speedMenu [data-speed-mode]');
            this.dom.speedModeButtons.forEach(button => {
                const modeType = button.dataset.speedMode;
                const modeConfig = SPEED_MODE_CONFIG[modeType];
                const isUnlocked = playerData.level >= modeConfig.unlockLevel;
                
                let buttonText = lang.get(button.dataset.langKey);
                if (!isUnlocked) {
                    buttonText += ` (${lang.get('level', { level: modeConfig.unlockLevel })})`;
                }
                button.textContent = buttonText;
                
                setupButton(button, isUnlocked, modeConfig.unlockLevel, () => this.game.startSpeedGame(modeType));
            });
        }
        
        displayPlayerPage(playerData) {
            if (this.dom.playerScreen.classList.contains('hidden')) {
                return;
            }

            let xpDisplayHTML;
            let xpBarHTML;
            const lang = this.game.lang;

            if (playerData.level >= CONSTANTS.MAX_LEVEL) {
                xpDisplayHTML = `<span class="stat-value" style="color: #f59e0b;">${lang.get('playerMaxLevel')}</span>`;
                xpBarHTML = `<div class="xp-bar-container"><div class="xp-bar" style="width: 100%; background-color: #f59e0b;"></div></div>`;
            } else {
                const xpPercent = (playerData.exp / playerData.expToNextLevel) * 100;
                xpDisplayHTML = `<span class="stat-value">${playerData.exp} / ${playerData.expToNextLevel}</span>`;
                xpBarHTML = `<div class="xp-bar-container"><div class="xp-bar" style="width: ${xpPercent}%"></div></div>`;
            }
            this.dom.playerStatsContainer.innerHTML = `<div class="player-stats"><div class="stat-item"><span class="stat-label">${lang.get('playerLevel')} </span><span class="stat-value">${playerData.level}</span></div><div class="stat-item"><span class="stat-label">${lang.get('playerExp')} </span>${xpDisplayHTML}</div>${xpBarHTML}</div>`;
            
            this.dom.historyContent.innerHTML = '';
            // Classic Mode History
            const classicDetails = document.createElement('details');
            classicDetails.innerHTML = `<summary>${lang.get('classicHistory')}</summary><div class="history-details"></div>`;
            const classicHistoryContainer = classicDetails.querySelector('.history-details');
            Object.keys(playerData.songs).forEach(songId => {
                const songData = playerData.songs[songId];
                if (!songData) return;
                const songInfo = SONG_LIBRARY[songId];
                let achievementText = songData.ap ? `<span class="achievement-ap">${lang.get('allPerfect')}</span>` : (songData.fc ? `<span class="achievement-fc">${lang.get('fullCombo')}</span>` : '');
                classicHistoryContainer.innerHTML += `<div class="history-entry"><div class="song-title">${songInfo.name[lang.currentLanguage]} ${achievementText}</div><div class="song-stats"><span class="stat-label">${lang.get('highScore')}</span> <span class="stat-value">${songData.highScore}</span><span class="stat-label">${lang.get('highRank')}</span> <span class="stat-value">${songData.highRank}</span><span class="stat-label">${lang.get('playCount')}</span> <span class="stat-value">${songData.playCount}</span></div></div>`;
            });
            this.dom.historyContent.appendChild(classicDetails);

            // Speed Mode History
            if (playerData.speedMode) {
                const speedDetails = document.createElement('details');
                speedDetails.innerHTML = `<summary>${lang.get('speedHistory')}</summary><div class="history-details"></div>`;
                const speedHistoryContainer = speedDetails.querySelector('.history-details');
                const modeNames = { fixed: lang.get('speedFixed'), random: lang.get('speedRandom') };
                Object.keys(playerData.speedMode).forEach(modeType => {
                    const modeData = playerData.speedMode[modeType];
                    if (!modeData) return;
                    speedHistoryContainer.innerHTML += `<div class="history-entry"><div class="song-title">${modeNames[modeType]}</div><div class="song-stats"><span class="stat-label">${lang.get('highCombo')}</span> <span class="stat-value">${modeData.highCombo}</span><span class="stat-label">${lang.get('highBpm')}</span> <span class="stat-value">${modeData.highBpm}</span><span class="stat-label">${lang.get('playCount')}</span> <span class="stat-value">${modeData.playCount}</span></div></div>`;
                });
                this.dom.historyContent.appendChild(speedDetails);
            }
        }
    }

    /**
     * PlayerDataManager: Manages loading, saving, and updating player data
     */
    class PlayerDataManager {
        constructor(gameInstance) {
            this.game = gameInstance;
            this.playerData = this.load();
        }

        getDefaultData() {
            return {
                version: CONSTANTS.CURRENT_VERSION, level: 1, exp: 0, expToNextLevel: 50, vibrationMode: 'off', inputMode: 'touch', language: 'zh',
                songs: { 'twinkle': { highScore: 0, highRank: 'D', playCount: 0, ap: false, fc: false, unlocked: true }, 'butterfly': { highScore: 0, highRank: 'D', playCount: 0, unlocked: false, ap: false, fc: false }, 'furElise': { highScore: 0, highRank: 'D', playCount: 0, unlocked: false, ap: false, fc: false }},
                speedMode: { fixed: { highCombo: 0, highBpm: 0, playCount: 0 }, random: { highCombo: 0, highBpm: 0, playCount: 0 }}
            };
        }
        
        load() {
            try {
                const savedJSON = localStorage.getItem(CONSTANTS.PLAYER_DATA_KEY);
                if (savedJSON) {
                    let savedData = JSON.parse(savedJSON);
                    return { ...this.getDefaultData(), ...savedData };
                }
            } catch (e) {
                console.error("Failed to load player data, resetting.", e);
                localStorage.removeItem(CONSTANTS.PLAYER_DATA_KEY);
            }
            return this.getDefaultData();
        }

        save() {
            try {
                this.playerData.version = CONSTANTS.CURRENT_VERSION;
                localStorage.setItem(CONSTANTS.PLAYER_DATA_KEY, JSON.stringify(this.playerData));
            } catch (e) {
                console.error("Failed to save player data.", e);
            }
        }

        addExp(amount) {
            if (this.playerData.level >= CONSTANTS.MAX_LEVEL) return;
            this.playerData.exp += amount;
            let leveledUp = false;
            while (this.playerData.exp >= this.playerData.expToNextLevel && this.playerData.level < CONSTANTS.MAX_LEVEL) {
                leveledUp = true;
                this.playerData.exp -= this.playerData.expToNextLevel;
                this.playerData.level++;
                if (this.playerData.level < CONSTANTS.MAX_LEVEL) {
                    this.playerData.expToNextLevel = Math.floor(this.playerData.expToNextLevel * 1.2 + 50);
                } else {
                    this.playerData.exp = 0;
                    this.playerData.expToNextLevel = 0;
                }
            }
            if (leveledUp) {
                alert(this.game.lang.get('levelUpAlert', {level: this.playerData.level}));
            }
            this.checkUnlocks(true);
            this.save();
        }
        
        checkUnlocks(isAfterLevelUp = false) {
             if (!this.playerData.songs.butterfly.unlocked && this.playerData.level >= SONG_LIBRARY.butterfly.unlockLevel) {
                this.playerData.songs.butterfly.unlocked = true;
                if(isAfterLevelUp) alert(this.game.lang.get('unlockSong', { songName: SONG_LIBRARY.butterfly.name[this.game.lang.currentLanguage] }));
            }
            if (!this.playerData.songs.furElise.unlocked && this.playerData.level >= SONG_LIBRARY.furElise.unlockLevel) {
                 this.playerData.songs.furElise.unlocked = true;
                 if(isAfterLevelUp) alert(this.game.lang.get('unlockSong', { songName: SONG_LIBRARY.furElise.name[this.game.lang.currentLanguage] }));
            }
        }
        
        updateClassicScore(songId, score, rank, counts) {
            const songData = this.playerData.songs[songId];
            if (!songData) return { text: '', class: '' };
            songData.playCount++;
            if (score > songData.highScore) songData.highScore = score;
            if (CONSTANTS.RANK_ORDER.indexOf(rank) > CONSTANTS.RANK_ORDER.indexOf(songData.highRank)) songData.highRank = rank;
            
            const isFC = counts.miss === 0 && (counts.perfect + counts.good) > 0;
            const isAP = isFC && counts.good === 0;
            
            let achievement = { text: '', class: ''};
            if (isAP) {
                songData.ap = true;
                achievement = { text: this.game.lang.get('allPerfect'), class: 'achievement-ap' };
            } else if (isFC) {
                songData.fc = true;
                achievement = { text: this.game.lang.get('fullCombo'), class: 'achievement-fc' };
            }
            this.save();
            return achievement;
        }
        
        updateSpeedScore(modeType, maxCombo, maxBPM) {
            const speedData = this.playerData.speedMode[modeType];
            if (speedData) {
                speedData.playCount++;
                if (maxCombo > speedData.highCombo) speedData.highCombo = maxCombo;
                if (maxBPM > speedData.highBpm) speedData.highBpm = maxBPM;
                this.save();
            }
        }

        getExportKey() {
            try {
                const dataString = JSON.stringify(this.playerData);
                return btoa(encodeURIComponent(dataString));
            } catch (e) {
                console.error('Export failed:', e);
                return null;
            }
        }

        calculateProgressScore(data) {
            if (!data || typeof data.level === 'undefined' || typeof data.exp === 'undefined') {
                return 0;
            }
            return (data.level * 100000) + data.exp;
        }

        importFromKey(key) {
            try {
                const decodedString = decodeURIComponent(atob(key));
                const importedData = JSON.parse(decodedString);
                if (!importedData || typeof importedData.level === 'undefined') {
                    throw new Error('Invalid key format');
                }

                const currentScore = this.calculateProgressScore(this.playerData);
                const importedScore = this.calculateProgressScore(importedData);
                const importedVersion = importedData.version || 2; 

                const proceedWithImport = () => {
                    this.playerData = { ...this.getDefaultData(), ...importedData };
                    this.save();
                    return true;
                }

                if (importedVersion < CONSTANTS.CURRENT_VERSION || importedScore < currentScore) {
                    if (confirm(this.game.lang.get('importWarningOldKey'))) {
                        return proceedWithImport();
                    }
                    return false;
                } else {
                    return proceedWithImport();
                }

            } catch (e) {
                console.error('Import failed:', e);
                alert(this.game.lang.get('importFail'));
                return false;
            }
        }
    }

    /**
     * Game: The main class that orchestrates everything
     */
    class Game {
        constructor() {
            this.state = 'UNINITIALIZED'; // UNINITIALIZED, READY, COUNTDOWN, PLAYING, PAUSED, GAMEOVER
            this.lang = new LanguageManager(this);
            this.ui = new UIManager(this);
            this.audio = new AudioManager();
            this.playerData = new PlayerDataManager(this);
            this.animationFrameId = null;
            this.speedNoteTimeout = null;
            this.gameMode = null; // 'CLASSIC' or 'SPEED'
            this.currentSongId = null;
            this.speedModeType = null;
            this.languageMenuReturnTarget = 'startScreen'; // Default return target
            this.resetGameStats();
            this.supportsVibration = 'vibrate' in navigator;
        }

        init() {
            this.ui.init();
            this.playerData.load();
            this.lang.init(); 
            this.ui.resize(document.querySelector('.game-wrapper'));
            window.addEventListener('resize', () => this.ui.resize(document.querySelector('.game-wrapper')));
            this.setupEventListeners();
            
            this.ui.updateVibrationButtons(this.playerData.playerData.vibrationMode);
            this.setInputMode(this.playerData.playerData.inputMode);

            if (!this.supportsVibration) {
                this.ui.dom.vibrationMenuButton.disabled = true;
            }
            
            this.state = 'INITIALIZED';
            this.ui.showScreen('startScreen');
        }

        setupEventListeners() {
            // Start & Menu Navigation
            this.ui.dom.startButton.addEventListener('click', () => this.startAudio());
            this.ui.dom.classicModeButton.addEventListener('click', () => this.ui.showScreen('classicMenu'));
            this.ui.dom.speedModeButton.addEventListener('click', () => this.ui.showScreen('speedMenu'));
            this.ui.dom.otherButton.addEventListener('click', () => this.ui.showScreen('otherMenu'));
            
            // Language & News Buttons
            this.ui.dom.startLanguageButton.addEventListener('click', () => {
                this.languageMenuReturnTarget = 'startScreen';
                this.ui.dom.languageBackBtn.dataset.target = this.languageMenuReturnTarget;
                this.ui.showScreen('languageMenu');
            });
            this.ui.dom.languageButton.addEventListener('click', () => {
                this.languageMenuReturnTarget = 'mainMenu';
                this.ui.dom.languageBackBtn.dataset.target = this.languageMenuReturnTarget;
                this.ui.showScreen('languageMenu');
            });
            this.ui.dom.newsButton.addEventListener('click', () => this.ui.showScreen('newsScreen'));
            
            this.ui.dom.backButtons.forEach(btn => btn.addEventListener('click', (e) => this.ui.showScreen(e.currentTarget.dataset.target)));
            this.ui.dom.homeButtons.forEach(btn => btn.addEventListener('click', (e) => this.goHome(e.currentTarget.dataset.target)));

            // Other Menu
            this.ui.dom.playerButton.addEventListener('click', () => {
                this.ui.showScreen('playerScreen');
            });
            this.ui.dom.saveDataButton.addEventListener('click', () => {
                this.ui.dom.saveDataKey.value = '';
                this.ui.showScreen('saveDataScreen');
            });
            this.ui.dom.modeMenuButton.addEventListener('click', () => this.ui.showScreen('modePopupMenu'));
            this.ui.dom.vibrationMenuButton.addEventListener('click', () => this.ui.showScreen('vibrationPopupMenu'));
            
            // In-Game
            this.ui.dom.pauseButton.addEventListener('click', () => this.togglePause());
            this.ui.dom.resumeButton.addEventListener('click', () => this.togglePause());
            this.ui.dom.pauseRestartButton.addEventListener('click', () => this.restart());
            this.ui.dom.exitButton.addEventListener('click', () => {
                if (confirm(this.lang.get('exitConfirm'))) {
                    this.goHome('mainMenu');
                }
            });

            // Settings
            this.ui.dom.touchModeBtn.addEventListener('click', () => this.setInputMode('touch'));
            this.ui.dom.keyboardModeBtn.addEventListener('click', () => this.setInputMode('keyboard'));
            this.ui.dom.modeSwitchButton.addEventListener('click', () => this.setInputMode(this.inputMode === 'touch' ? 'keyboard' : 'touch'));
            
            this.ui.dom.vibrationButtons.forEach(btn => btn.addEventListener('click', e => {
                this.setVibrationMode(e.currentTarget.dataset.vibration);
                this.triggerVibration('hit_strong');
            }));
             this.ui.dom.vibrationHelpBtn.addEventListener('click', () => alert(this.lang.get('vibrationHelp')));

            // Save/Load
            this.ui.dom.exportSaveData.addEventListener('click', () => this.exportSaveData());
            this.ui.dom.importSaveData.addEventListener('click', () => this.importSaveData());
            
            // Input Handling
            const setupKey = (button, lane) => {
                const press = (e) => { e.preventDefault(); if (this.state === 'PLAYING') this.handleHit(lane); button.classList.add('active'); };
                const release = (e) => { e.preventDefault(); button.classList.remove('active'); };
                button.addEventListener('touchstart', press, { passive: false });
                button.addEventListener('touchend', release);
                button.addEventListener('mousedown', press);
                button.addEventListener('mouseup', release);
                button.addEventListener('mouseleave', () => button.classList.remove('active'));
            };
            this.ui.dom.keyButtons.forEach((btn, i) => setupKey(btn, i));

            window.addEventListener('keydown', e => {
                if (this.state === 'PLAYING' && this.inputMode === 'keyboard' && !e.repeat) {
                    const lane = {'a': 0, 's': 1, 'd': 2, 'f': 3}[e.key.toLowerCase()];
                    if (lane !== undefined) {
                        this.handleHit(lane);
                        this.ui.dom.keyButtons[lane].classList.add('active');
                    }
                }
                if (e.key === 'Escape' && (this.state === 'PLAYING' || this.state === 'PAUSED')) this.togglePause();
            });
            window.addEventListener('keyup', e => {
                if (this.inputMode === 'keyboard') {
                    const lane = {'a': 0, 's': 1, 'd': 2, 'f': 3}[e.key.toLowerCase()];
                    if (lane !== undefined) this.ui.dom.keyButtons[lane].classList.remove('active');
                }
            });
        }
        
        async startAudio() {
            if (this.audio.isReady) {
                this.ui.updateAllUnlocks(this.playerData.playerData);
                this.ui.showScreen('mainMenu');
                return;
            };
            try {
                await this.audio.init();
                this.state = 'READY';
                this.ui.updateAllUnlocks(this.playerData.playerData);
                this.ui.showScreen('mainMenu');
            } catch (e) {
                this.ui.dom.startButton.textContent = this.lang.get('audioError');
                this.ui.dom.startButton.disabled = true;
                alert(this.lang.get('audioError'));
            }
        }

        resetGameStats() {
            this.score = 0;
            this.combo = 0;
            this.maxCombo = 0;
            this.hitCounts = { perfect: 0, good: 0, miss: 0 };
            this.notes = [];
            this.songDuration = 0;
            this.currentBPM = 100;
            this.maxBPM = 100;
            this.lastBPMUpdateTime = 0;
            if (this.animationFrameId) {
                cancelAnimationFrame(this.animationFrameId);
                this.animationFrameId = null;
            }
            if (this.speedNoteTimeout) {
                clearTimeout(this.speedNoteTimeout);
                this.speedNoteTimeout = null;
            }
        }
        
        goHome(targetScreen) {
            this.state = 'READY';
            this.audio.stopAndReset();
            this.resetGameStats();
            this.ui.resetInGameUI();
            this.ui.draw([]);
            if (targetScreen) {
                this.ui.updateAllUnlocks(this.playerData.playerData);
                this.ui.showScreen(targetScreen);
            }
        }

        startClassicGame(songId) {
            this.audio.stopAndReset();
            this.resetGameStats();
            
            this.gameMode = 'CLASSIC';
            this.currentSongId = songId;

            const songData = SONG_LIBRARY[songId];
            this.currentBPM = songData.bpm;
            const secondsPerBeat = 60.0 / songData.bpm; 
            const beatOffset = 2; 
            this.notes = songData.beatmap.map(([beat, lane, pitch]) => {
                const hitTime = (beat - 1 + beatOffset) * secondsPerBeat;
                return { lane, pitch, hitTime, y: -100, isHit: false, isMissed: false };
            }); 
            this.songDuration = this.notes.length > 0 ? this.notes[this.notes.length - 1].hitTime + 2 : 0;
            
            this.state = 'COUNTDOWN';
            this.ui.showCountdown(3, () => this.startGame());
        }

        startSpeedGame(modeType) {
            this.audio.stopAndReset();
            this.resetGameStats();

            this.gameMode = 'SPEED';
            this.speedModeType = modeType;
            this.currentBPM = 100;
            this.maxBPM = 100;

            this.state = 'COUNTDOWN';
            this.ui.showCountdown(3, () => this.startGame());
        }

        startGame() {
            this.state = 'PLAYING';
            const vibrationCallback = this.playerData.playerData.vibrationMode.startsWith('rhythm') 
                ? () => this.triggerVibration('rhythm') 
                : null;
            this.audio.startTransport(this.currentBPM, vibrationCallback);
            
            if (this.gameMode === 'SPEED') {
                this.lastBPMUpdateTime = this.audio.getCurrentTime();
                this.scheduleNextSpeedNote();
            }
            this.animationFrameId = requestAnimationFrame(() => this.loop());
        }
        
        loop() {
            if (this.state !== 'PLAYING') return;

            const currentTime = this.audio.getCurrentTime();
            
            for (let i = this.notes.length - 1; i >= 0; i--) {
                const note = this.notes[i];
                if (!note.isHit && !note.isMissed && note.hitTime < currentTime - CONSTANTS.GOOD_THRESHOLD) {
                    note.isMissed = true;
                    this.handleJudgment('miss', note.lane);
                }
            }
            // Filter out notes that are already hit or missed.
            this.notes = this.notes.filter(note => !note.isHit && !note.isMissed);

            this.notes.forEach(note => {
                const timeUntilHit = note.hitTime - currentTime;
                note.y = this.ui.hitLineY * (1 - timeUntilHit / CONSTANTS.FALL_TIME_SECONDS);
            });

            if (this.gameMode === 'CLASSIC') {
                if (currentTime > this.songDuration && this.notes.length === 0) {
                    this.endGame();
                    return;
                }
            }
            
            if (this.gameMode === 'SPEED') {
                if (currentTime - this.lastBPMUpdateTime >= 2) { 
                    this.currentBPM *= 1.05; 
                    if (this.currentBPM > this.maxBPM) this.maxBPM = this.currentBPM; 
                    this.audio.setBPM(this.currentBPM);
                    this.lastBPMUpdateTime = currentTime; 
                }
            }
            
            this.ui.updateInGameUI({
                score: this.score,
                combo: this.combo,
                bpm: this.currentBPM,
                progress: this.gameMode === 'CLASSIC' ? (currentTime / this.songDuration) : 0,
                showProgressBar: this.gameMode === 'CLASSIC',
                showPause: true
            });
            this.ui.draw(this.notes);
            this.animationFrameId = requestAnimationFrame(() => this.loop());
        }

        handleHit(lane) {
            const currentTime = this.audio.getCurrentTime();
            let noteToHit = null;
            let bestTimeDiff = Infinity;
            
            for (const note of this.notes) {
                if (!note.isHit && !note.isMissed && note.lane === lane) {
                    const timeDiff = Math.abs(currentTime - note.hitTime);
                    if (timeDiff <= CONSTANTS.GOOD_THRESHOLD && timeDiff < bestTimeDiff) {
                        bestTimeDiff = timeDiff;
                        noteToHit = note;
                    }
                }
            }
            
            if (noteToHit) {
                noteToHit.isHit = true;
                const judgment = bestTimeDiff <= CONSTANTS.PERFECT_THRESHOLD ? 'perfect' : 'good';
                this.handleJudgment(judgment, lane, noteToHit.pitch);
            }
        }
        
        handleJudgment(type, lane, pitch) {
            if (this.state !== 'PLAYING') return;

            if (type === 'perfect' || type === 'good') {
                this.combo++;
                const multiplier = this.getComboMultiplier(this.combo);
                this.score += Math.floor((type === 'perfect' ? 100 : 50) * multiplier);
                this.hitCounts[type]++;
                this.ui.showHitFeedback(type);
                this.audio.playNote(pitch);
                this.triggerVibration('hit');
            } else if (type === 'miss') {
                this.combo = 0;
                this.hitCounts.miss++;
                this.ui.showHitFeedback('miss');
                if (this.gameMode === 'SPEED') {
                    this.endGame();
                    return;
                }
            }
            if (this.combo > this.maxCombo) this.maxCombo = this.combo;
        }
        
        endGame() {
            if (this.state !== 'PLAYING') return;
            this.state = 'GAMEOVER';
            this.audio.stopAndReset();
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
            if(this.speedNoteTimeout) clearTimeout(this.speedNoteTimeout);
            this.speedNoteTimeout = null;

            const totalNotesJudged = this.hitCounts.perfect + this.hitCounts.good + this.hitCounts.miss;
            const accuracy = totalNotesJudged > 0 ? ((this.hitCounts.perfect + this.hitCounts.good * 0.5) / totalNotesJudged) * 100 : 100;

            let results = {
                counts: this.hitCounts, score: this.score, maxCombo: this.maxCombo,
                accuracy: accuracy, expGained: 0
            };

            if (this.gameMode === 'CLASSIC') {
                let rank = 'D';
                if (accuracy >= 99) rank = 'S++'; else if (accuracy >= 98) rank = 'S+'; else if (accuracy >= 96) rank = 'S';
                else if (accuracy >= 93) rank = 'S-'; else if (accuracy >= 90) rank = 'A+'; else if (accuracy >= 85) rank = 'A';
                else if (accuracy >= 80) rank = 'A-'; else if (accuracy >= 75) rank = 'B+'; else if (accuracy >= 70) rank = 'B';
                else if (accuracy >= 65) rank = 'B-'; else if (accuracy >= 60) rank = 'C+'; else if (accuracy >= 55) rank = 'C';
                else if (accuracy >= 50) rank = 'C-';

                const rankIndex = CONSTANTS.RANK_ORDER.indexOf(rank);
                if (rankIndex >= CONSTANTS.RANK_ORDER.indexOf('S-')) results.expGained = 30; 
                else if (rankIndex >= CONSTANTS.RANK_ORDER.indexOf('A-')) results.expGained = 25; 
                else if (rankIndex >= CONSTANTS.RANK_ORDER.indexOf('B-')) results.expGained = 20; 
                else if (rankIndex >= CONSTANTS.RANK_ORDER.indexOf('C-')) results.expGained = 15; 
                else results.expGained = 8;

                results.title = this.lang.get('gameOverTitleClassic');
                results.rank = rank;
                results.achievement = this.playerData.updateClassicScore(this.currentSongId, this.score, rank, this.hitCounts);

            } else { // SPEED MODE
                results.title = this.lang.get('gameOverTitleSpeed');
                results.maxBPM = Math.floor(this.maxBPM);
                results.expGained = Math.round(this.maxCombo / 3);
                results.achievement = { text: '', class: '' };
                this.playerData.updateSpeedScore(this.speedModeType, this.maxCombo, results.maxBPM);
            }
            
            if (this.playerData.playerData.level >= CONSTANTS.MAX_LEVEL) {
                results.expGained = 0;
            }
            
            this.playerData.addExp(results.expGained);
            this.ui.showGameOver(results);
        }

        scheduleNextSpeedNote() {
            if (this.state !== 'PLAYING') return;
            const hitTime = this.audio.getCurrentTime() + CONSTANTS.FALL_TIME_SECONDS;
            const lane = this.speedModeType === 'random' ? Math.floor(Math.random() * CONSTANTS.LANE_COUNT) : 2;
            const pitch = ["C4", "E4", "G4", "C5"][lane];
            this.notes.push({ lane, pitch, hitTime, y: -100, isHit: false, isMissed: false });
            
            const secondsPerBeat = 60.0 / this.currentBPM;
            this.speedNoteTimeout = setTimeout(() => this.scheduleNextSpeedNote(), secondsPerBeat * 1000);
        }

        getComboMultiplier(combo) { if (combo >= 100) return 4.2; if (combo >= 90) return 3.9; if (combo >= 80) return 3.6; if (combo >= 70) return 3.3; if (combo >= 60) return 3.0; if (combo >= 50) return 2.7; if (combo >= 40) return 2.4; if (combo >= 30) return 2.1; if (combo >= 20) return 1.8; if (combo >= 10) return 1.5; if (combo >= 5) return 1.2; return 1.0; }
        
        togglePause() {
            if (this.state === 'PLAYING') this.pause();
            else if (this.state === 'PAUSED') this.resume();
        }

        pause() {
            if (this.state !== 'PLAYING') return;
            this.state = 'PAUSED';
            this.audio.pause();
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
            if (this.speedNoteTimeout) clearTimeout(this.speedNoteTimeout);
            this.ui.showScreen('pauseOverlay');
        }
        
        resume() {
            if (this.state !== 'PAUSED') return;
            this.state = 'PLAYING';
            this.audio.resume();
            if (this.gameMode === 'SPEED') this.scheduleNextSpeedNote();
            this.animationFrameId = requestAnimationFrame(() => this.loop());
            this.ui.showScreen('none');
        }
        
        restart() {
            if (this.state !== 'PAUSED') return;
            this.ui.showScreen('none'); // Hide pause overlay
            if (this.gameMode === 'CLASSIC') {
                this.startClassicGame(this.currentSongId);
            } else if (this.gameMode === 'SPEED') {
                this.startSpeedGame(this.speedModeType);
            }
        }

        setInputMode(mode) {
            this.inputMode = mode;
            this.playerData.playerData.inputMode = mode;
            this.playerData.save();
            this.ui.updateKeyLabels(mode);
            this.ui.updateModeButtons(mode);
        }

        setVibrationMode(mode) {
            this.vibrationMode = mode;
            this.playerData.playerData.vibrationMode = mode;
            this.playerData.save();
            this.ui.updateVibrationButtons(mode);
        }
        
        triggerVibration(type) {
            if (!this.supportsVibration || this.playerData.playerData.vibrationMode === 'off') return;
            const patterns = { hit_weak: 35, hit_strong: 70, rhythm_weak: 15, rhythm_strong: 30 };
            const currentMode = this.playerData.playerData.vibrationMode;
            if (currentMode.startsWith(type)) {
                navigator.vibrate(patterns[currentMode]);
            }
        }
        
        exportSaveData() {
            const key = this.playerData.getExportKey();
            if (key) {
                this.ui.dom.saveDataKey.value = key;
                this.ui.dom.saveDataKey.select();
                navigator.clipboard.writeText(key)
                    .then(() => alert(this.lang.get('exportSuccess')))
                    .catch(() => alert(this.lang.get('exportFail')));
            } else {
                alert('Export failed!');
            }
        }

        importSaveData() {
            const key = prompt(this.lang.get('importPrompt'));
            if (key) {
                if (this.playerData.importFromKey(key)) {
                    this.lang.setLanguage(this.playerData.playerData.language || 'zh', false); // Set language without saving again
                    this.setVibrationMode(this.playerData.playerData.vibrationMode);
                    this.setInputMode(this.playerData.playerData.inputMode);
                    this.ui.updateAllUnlocks(this.playerData.playerData);
                    alert(this.lang.get('importSuccess'));
                    this.ui.showScreen('otherMenu');
                }
            }
        }
    }

    // --- Entry Point ---
    window.addEventListener('DOMContentLoaded', () => {
        const game = new Game();
        game.init();
    });

    </script>
</body>
</html>