<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <!-- The page title will be set by JavaScript -->
    <title>音符醬 (Version 2.0)</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&family=Noto+Sans+KR:wght@400;700&family=Noto+Sans+SC:wght@400;700&family=Noto+Sans+TC:wght@400;700&family=Poppins:wght@400;700&display=swap" rel="stylesheet">
    <!-- Scripts -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        body { 
            /* Unified Font Family */
            font-family: 'Poppins', 'Noto Sans TC', 'Noto Sans SC', 'Noto Sans JP', 'Noto Sans KR', sans-serif;
            background-color: #111827; 
            color: #e5e7eb; 
            margin: 0; 
            overflow: hidden; 
            -webkit-tap-highlight-color: transparent; 
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }
        .game-wrapper {
            background-color: #1f2937; 
            position: relative; 
            display: flex; 
            flex-direction: column; 
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            overflow: hidden;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }
        .game-header { width: 100%; display: flex; flex-direction: column; align-items: center; padding: 2.5rem 1rem 1rem 1rem; box-sizing: border-box; background: linear-gradient(to bottom, rgba(31, 41, 55, 0.9), transparent); }
        .stats-container { width: 100%; display: flex; justify-content: space-between; align-items: center; }
        .score-display, .combo-display { font-size: 1.5rem; font-weight: bold; text-shadow: 0 0 5px black; flex: 1; }
        .score-display { text-align: left; color: #f9fafb; }
        .combo-display { text-align: right; color: #f59e0b; transition: transform 0.1s ease; }
        .bpm-display { font-size: 1.2rem; color: #9ca3af; margin-top: 0.5rem; font-weight: bold; }
        #pauseButton { pointer-events: auto; background-color: #4b5563; color: white; border-radius: 0.375rem; padding: 0.5rem 1rem; font-weight: bold; transition: background-color 0.2s; flex-shrink: 0; }
        #pauseButton:hover { background-color: #6b7280; }
        #progressBarContainer { width: 90%; height: 8px; background-color: #4b5563; border-radius: 4px; overflow: hidden; margin-top: 1rem; }
        #progressBar { height: 100%; width: 0%; background-color: #a78bfa; transition: width 0.1s linear; }
        .hit-feedback { position: absolute; left: 50%; bottom: 35%; font-size: 2.5rem; font-weight: bold; text-shadow: 0 0 10px black; opacity: 0; transition: opacity 0.3s ease, transform 0.3s ease; transform: translate(-50%, 0) scale(0.8); }
        .hit-feedback.show { opacity: 1; transform: translate(-50%, -20px) scale(1); }
        .hit-feedback.perfect { color: #22c55e; } .hit-feedback.good { color: #eab308; } .hit-feedback.miss { color: #ef4444; }
        .game-footer { width: 100%; display: flex; height: 120px; pointer-events: auto; position: absolute; bottom: 40px; }
        .key-button { flex: 1; background-color: rgba(55, 65, 81, 0.5); border-top: 4px solid #4b5563; transition: background-color 0.1s, border-color 0.1s; display: flex; justify-content: center; align-items: center; color: #9ca3af; font-size: 2rem; font-weight: bold; }
        .key-button.active { background-color: rgba(200, 200, 255, 0.3); border-color: #a78bfa; }
        .key-label { transition: opacity 0.3s; }
        .screen-overlay, .pause-overlay, #countdownOverlay { position: absolute; inset: 0; background-color: rgba(0, 0, 0, 0.85); z-index: 20; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; color: white; padding: 2rem; box-sizing: border-box;}
        .screen-overlay.hidden, .pause-overlay.hidden, #countdownOverlay.hidden { display: none; }
        
        .scrollable-menu {
            justify-content: flex-start;
            overflow-y: auto;
        }
        .scrollable-menu .back-button {
            margin-bottom: 2rem;
            margin-top: auto;
        }
        .scrollable-menu > .song-selection {
             padding-top: 2rem;
        }

        .screen-overlay h1, .pause-overlay h1, .popup-menu h1 { font-size: 3rem; margin-bottom: 0.5rem; color: #d1d5db; }
        .screen-overlay p, .popup-menu p { font-size: 1.1rem; color: #9ca3af; margin-bottom: 1.5rem; }

        #countdownOverlay { font-size: 10rem; font-weight: bold; text-shadow: 0 0 20px black; background-color: transparent; z-index: 30;}
        #gameOverScreen .result-grid { display: grid; grid-template-columns: auto auto; justify-content: center; gap: 0.5rem 2rem; margin-bottom: 1rem; font-size: 1.2rem; }
        #gameOverScreen .result-label { text-align: right; color: #9ca3af; }
        #gameOverScreen .result-value { text-align: left; font-weight: bold; }
        #rankDisplay { font-size: 6rem; font-weight: bold; margin-bottom: 0rem; transition: color 0.3s; }
        #achievementDisplay { font-size: 2rem; font-weight: bold; margin-bottom: 1rem; height: 2rem; }
        .achievement-ap { color: #ef4444; } .achievement-fc { color: #22c55e; } 
        .rank-s { color: #a78bfa; } .rank-a { color: #eab308; } .rank-b { color: #3b82f6; } .rank-c { color: #f97316; } .rank-d { color: #6b7280; }
        .overlay-button { background-color: #a78bfa; color: white; font-size: 1.5rem; font-weight: bold; border: none; border-radius: 9999px; padding: 0.8rem 1rem; cursor: pointer; transition: background-color 0.2s, transform 0.1s; width: 100%; }
        .overlay-button:hover { background-color: #8b5cf6; }
        .overlay-button:active { transform: scale(0.95); }
        .overlay-button.secondary { background-color: #4b5563; }
        .overlay-button.secondary:hover { background-color: #6b7280; }
        .overlay-button.danger { background-color: #ef4444; }
        .overlay-button.danger:hover { background-color: #dc2626; }
        .overlay-button.locked { background-color: #374151; color: #6b7280; cursor: pointer; }
        .overlay-button.locked:hover { background-color: #4b5563; }
        
        .song-selection { display: flex; flex-direction: column; gap: 1rem; width: 100%; max-width: 380px; align-items: center;}
        .song-selection .overlay-button { margin-top: 0; }
        
        .main-setting-btn {
            height: 64px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1.2;
            padding: 0.5rem 1rem;
        }

        .setting-group {
            width: 100%;
            border: 1px solid #4b5563;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        .setting-group-title {
            color: #9ca3af;
            font-weight: bold;
            margin-bottom: 0.75rem;
            text-align: left;
        }
        .setting-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
        }


        textarea#saveDataKey { background-color: #374151; border: 1px solid #4b5563; color: white; width: 100%; margin-top: 1rem; padding: 0.5rem; border-radius: 0.25rem; }
        
        #playerScreen .player-stats-container { text-align: center; width:100%;}
        #playerScreen .player-stats { display: flex; flex-direction: column; align-items: center; gap: 0.5rem; width: 100%; }
        #playerScreen .stat-item { font-size: 1.2rem; }
        #playerScreen .stat-label { color: #9ca3af; }
        #playerScreen .stat-value { font-weight: bold; }
        #playerScreen .history-list { width: 100%; max-width: 380px; margin-top: 1.5rem; }
        #playerScreen details { background-color: rgba(55, 65, 81, 0.5); border-radius: 0.5rem; margin-bottom: 1rem; }
        #playerScreen summary { font-size: 1.25rem; font-weight: bold; padding: 1rem; cursor: pointer; list-style: none; }
        #playerScreen summary::-webkit-details-marker { display: none; }
        #playerScreen summary::after { content: ' ▸'; float: right; transition: transform 0.2s; }
        #playerScreen details[open] summary::after { transform: rotate(90deg); }
        #playerScreen .history-details { padding: 0 1rem 1rem 1rem; }
        #playerScreen .history-entry { border-top: 1px solid #4b5563; padding-top: 1rem; margin-top: 1rem; }
        #playerScreen .history-entry:first-child { border-top: none; margin-top: 0; padding-top: 0; }
        #playerScreen .song-title { font-size: 1.1rem; font-weight: bold; }
        #playerScreen .song-stats { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.25rem 1rem; font-size: 0.9rem; margin-top: 0.5rem; }

        .xp-bar-container { width: 100%; background-color: #4b5563; border-radius: 9999px; overflow: hidden; height: 1.25rem; margin-top: 0.5rem;}
        .xp-bar { background-color: #a78bfa; height: 100%; width: 0%; transition: width 0.5s ease-out; text-align: center; color: white; font-size: 0.8rem; line-height: 1.25rem;}
        
        /* Language Drawer Styles */
        .language-drawer {
            width: 100%;
            position: relative;
        }
        summary.language-button {
            background-color: #4b5563;
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 9999px;
            cursor: pointer;
            list-style: none; /* Hide the default marker */
            transition: background-color 0.2s;
            font-weight: bold;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 64px;
        }
        summary.language-button::-webkit-details-marker {
            display: none;
        }
        summary.language-button:hover {
            background-color: #6b7280;
        }
        .language-options {
            position: absolute;
            left: 0;
            right: 0;
            background-color: #374151;
            border: 1px solid #4b5563;
            z-index: 40; /* Make sure it's on top */
            display: flex;
            flex-direction: column;
            overflow: hidden;
            pointer-events: auto; /* Enable clicks on options */
        }
        .language-options button {
            background: none;
            border: none;
            color: #d1d5db;
            padding: 0.75rem 1rem;
            text-align: center;
            width: 100%;
            cursor: pointer;
            font-size: 1.1rem;
        }
        .language-options button:not(:last-child) {
            border-bottom: 1px solid #4b5563;
        }
        .language-options button:hover {
            background-color: #4b5563;
        }
        .language-options button.active {
            background-color: #a78bfa;
            color: white;
            font-weight: bold;
        }

        /* Default: Dropdown */
        .language-options {
            top: 100%;
            border-top: none;
            border-bottom-left-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
        }
        .language-drawer[open] > summary.language-button {
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }
        
        /* Specific override for Start Screen: Pop-up */
        #startScreen .language-options {
            top: auto;
            bottom: 100%;
            border-bottom: none;
            border-top: 1px solid #4b5563;
            border-top-left-radius: 0.5rem;
            border-top-right-radius: 0.5rem;
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }
        #startScreen .language-drawer[open] > summary.language-button {
            border-top-left-radius: 0;
            border-top-right-radius: 0;
            border-bottom-left-radius: 9999px;
            border-bottom-right-radius: 9999px;
        }

    </style>
</head>
<body>
    <div class="game-wrapper">
        <canvas id="gameCanvas"></canvas>
        <div class="ui-layer">
            <div class="game-header">
                <div class="stats-container">
                    <div id="scoreDisplay" class="score-display">0</div>
                    <button id="pauseButton" class="hidden" data-lang-key="pause">暫停</button>
                    <div id="comboDisplay" class="combo-display"></div>
                </div>
                <div id="bpmDisplay" class="bpm-display hidden">BPM: 100</div>
                <div id="progressBarContainer">
                    <div id="progressBar"></div>
                </div>
            </div>
            <div id="hitFeedback" class="hit-feedback">PERFECT</div>
            <div class="game-footer">
                <div class="key-button" data-lane="0"><span class="key-label">A</span></div>
                <div class="key-button" data-lane="1"><span class="key-label">S</span></div>
                <div class="key-button" data-lane="2"><span class="key-label">D</span></div>
                <div class="key-button" data-lane="3"><span class="key-label">F</span></div>
            </div>
        </div>
        <div id="startScreen" class="screen-overlay">
            <div class="song-selection">
                <h1 data-lang-key="gameTitle">音符醬</h1>
                <p data-lang-key="startScreenPrompt">為了最好的遊戲體驗，請點擊開始</p>
                <!-- Language drawer moved before the start button -->
                <details class="language-drawer" id="startLanguageDrawer">
                    <summary class="language-button" id="startLangBtn">語言</summary>
                    <div class="language-options">
                        <button data-lang="zh">繁體中文</button>
                        <button data-lang="zh-CN">简体中文</button>
                        <button data-lang="en">English</button>
                        <button data-lang="ja">日本語</button>
                        <button data-lang="ko">한국어</button>
                    </div>
                </details>
                <button id="startButton" class="overlay-button main-setting-btn" data-lang-key="clickToStart">點擊以開始</button>
            </div>
        </div>
        <div id="mainMenu" class="screen-overlay scrollable-menu hidden">
            <div class="song-selection">
                <h1 data-lang-key="gameTitle">音符醬</h1>
                <p data-lang-key="mainMenuPrompt">選擇你的遊戲模式！</p>
                <button id="classicModeButton" class="overlay-button main-setting-btn" data-lang-key="classicModeButton">經典演奏模式</button>
                <button id="speedModeButton" class="overlay-button main-setting-btn" data-lang-key="speedModeButton">極限手速模式</button>
                <button id="otherButton" class="overlay-button secondary main-setting-btn" data-lang-key="otherButton">其他</button>
            </div>
        </div>
        <div id="otherMenu" class="screen-overlay hidden scrollable-menu">
            <div class="song-selection">
                <h1 style="padding-top: 2rem;" data-lang-key="otherTitle">其他</h1>
                
                <details class="language-drawer" id="otherLanguageDrawer">
                    <summary class="language-button" id="otherLangBtn">語言</summary>
                    <div class="language-options">
                        <button data-lang="zh">繁體中文</button>
                        <button data-lang="zh-CN">简体中文</button>
                        <button data-lang="en">English</button>
                        <button data-lang="ja">日本語</button>
                        <button data-lang="ko">한국어</button>
                    </div>
                </details>

                <button id="playerButton" class="overlay-button main-setting-btn" data-lang-key="playerButton">玩家</button>
                <button id="saveDataButton" class="overlay-button main-setting-btn" data-lang-key="saveDataButton">存檔管理</button>
                <button id="modeMenuButton" class="overlay-button main-setting-btn" data-lang-key="modeMenuButton">遊戲模式</button>
                <button id="vibrationMenuButton" class="overlay-button main-setting-btn" data-lang-key="vibrationMenuButton">震動設定</button>
                <button class="overlay-button secondary back-button main-setting-btn" data-target="mainMenu" data-lang-key="backToMain">返回主選單</button>
            </div>
        </div>
        <div id="modePopupMenu" class="screen-overlay hidden scrollable-menu">
            <div class="song-selection">
                <h1 data-lang-key="modeMenuTitle">遊戲模式</h1>
                <p data-lang-key="modeMenuPrompt">選擇適合你的操作方式</p>
                <div id="modeSelectionContainer" style="display: flex; gap: 1rem; justify-content: center; width:100%;">
                    <button id="touchModeBtn" class="overlay-button main-setting-btn" data-lang-key="touchMode">手機觸控</button>
                    <button id="keyboardModeBtn" class="overlay-button secondary main-setting-btn" data-lang-key="keyboardMode">電腦鍵盤</button>
                </div>
                <button class="overlay-button secondary back-button main-setting-btn" data-target="otherMenu" data-lang-key="back">返回</button>
            </div>
        </div>
        <div id="vibrationPopupMenu" class="screen-overlay hidden scrollable-menu">
            <div class="song-selection">
                <h1 data-lang-key="vibrationMenuTitle">震動設定</h1>
                <p data-lang-key="vibrationMenuPrompt">選擇您偏好的震動模式</p>
                <button class="overlay-button main-setting-btn" data-vibration="off" style="grid-column: 1 / -1;" data-lang-key="off">關閉</button>
                <div class="setting-group">
                    <div class="setting-group-title" data-lang-key="vibrationOnHit">僅打擊時</div>
                    <div class="setting-options">
                        <button class="overlay-button secondary" data-vibration="hit_weak" data-lang-key="weak">弱</button>
                        <button class="overlay-button secondary" data-vibration="hit_strong" data-lang-key="strong">強</button>
                    </div>
                </div>
                <div class="setting-group">
                    <div class="setting-group-title" data-lang-key="vibrationFollowRhythm">跟隨節奏</div>
                     <div class="setting-options">
                        <button class="overlay-button secondary" data-vibration="rhythm_weak" data-lang-key="weak">弱</button>
                        <button class="overlay-button secondary" data-vibration="rhythm_strong" data-lang-key="strong">強</button>
                    </div>
                </div>
                <button id="vibrationHelpBtn" class="overlay-button secondary main-setting-btn" style="margin-top: 1rem;" data-lang-key="moreInfo">更多說明</button>
                <button class="overlay-button secondary back-button main-setting-btn" data-target="otherMenu" data-lang-key="back">返回</button>
            </div>
        </div>
        <div id="classicMenu" class="screen-overlay hidden scrollable-menu">
            <div class="song-selection">
                <h1 data-lang-key="classicModeTitle">經典演奏模式</h1>
                <p data-lang-key="classicModePrompt">選擇一首歌曲開始挑戰！</p>
                <button class="overlay-button main-setting-btn" data-song="furElise"></button>
                <button class="overlay-button main-setting-btn" data-song="butterfly"></button>
                <button class="overlay-button main-setting-btn" data-song="twinkle"></button>
                <button class="overlay-button secondary back-button main-setting-btn" data-target="mainMenu" data-lang-key="backToMain">返回主選單</button>
            </div>
        </div>
        <div id="speedMenu" class="screen-overlay hidden scrollable-menu">
             <div class="song-selection">
                <h1 data-lang-key="speedModeTitle">極限手速模式</h1>
                <p data-lang-key="speedModePrompt">BPM將持續提升，挑戰你的極限！</p>
                <button class="overlay-button main-setting-btn" data-speed-mode="fixed" data-lang-key="speedFixed"></button>
                <button class="overlay-button main-setting-btn" data-speed-mode="random" data-lang-key="speedRandom"></button>
                <button class="overlay-button secondary back-button main-setting-btn" data-target="mainMenu" data-lang-key="backToMain">返回主選單</button>
            </div>
        </div>
        <div id="gameOverScreen" class="screen-overlay hidden">
            <h1 id="gameOverTitle">演奏結束</h1>
            <div id="rankDisplayContainer">
                <div id="rankDisplay">S++</div>
                <div id="achievementDisplay"></div>
            </div>
            <div class="result-grid">
                <div class="result-label" data-lang-key="finalAccuracy">最終精準度 :</div><div id="finalAccuracy" class="result-value">0.00%</div>
                <div class="result-label" data-lang-key="finalScore">最終分數 :</div><div id="finalScore" class="result-value">0</div>
                <div class="result-label">Perfect :</div><div id="perfectCount" class="result-value">0</div>
                <div class="result-label">Good :</div><div id="goodCount" class="result-value">0</div>
                <div class="result-label">Miss :</div><div id="missCount" class="result-value">0</div>
                <div class="result-label" data-lang-key="finalMaxCombo">最高 Combo :</div><div id="finalMaxCombo" class="result-value">0</div>
                <div class="result-label" id="finalBpmLabel" data-lang-key="finalBPM">最高 BPM :</div><div id="finalBPM" class="result-value">0</div>
                <div class="result-label" data-lang-key="expGained">獲得經驗 :</div><div id="expGained" class="result-value">0</div>
            </div>
            <button class="overlay-button home-button" data-target="mainMenu" data-lang-key="backToMain">回到主選單</button>
        </div>
        <div id="saveDataScreen" class="screen-overlay hidden scrollable-menu">
            <div class="song-selection">
                <h1 data-lang-key="saveDataTitle">存檔管理</h1>
                <p data-lang-key="saveDataPrompt">複製金鑰備份，或貼上金鑰還原紀錄。</p>
                <textarea id="saveDataKey" rows="4" readonly></textarea>
                <div style="display: flex; gap: 1rem; width: 100%;">
                    <button id="exportSaveData" class="overlay-button main-setting-btn" data-lang-key="exportKey">匯出金鑰</button>
                    <button id="importSaveData" class="overlay-button secondary main-setting-btn" data-lang-key="importKey">匯入金鑰</button>
                </div>
                <button class="overlay-button secondary back-button main-setting-btn" data-target="otherMenu" data-lang-key="back">返回</button>
            </div>
        </div>
        <div id="playerScreen" class="screen-overlay hidden scrollable-menu">
             <div class="song-selection">
                <h1 style="padding-top: 2rem;" data-lang-key="playerTitle">玩家</h1>
                <div class="player-stats-container" id="playerStatsContainer" style="width: 100%;"></div>
                <div class="history-list" id="historyContent" style="width: 100%;"></div>
                <button class="overlay-button secondary back-button" data-target="otherMenu" style="margin-top: 2rem; margin-bottom: 2rem;" data-lang-key="back">返回</button>
            </div>
        </div>
        <div id="pauseOverlay" class="pause-overlay hidden">
            <div class="song-selection">
                <h1 data-lang-key="pauseTitle">遊戲暫停</h1>
                <button id="resumeButton" class="overlay-button main-setting-btn" data-lang-key="resume">繼續遊戲</button>
                <button id="modeSwitchButton" class="overlay-button secondary main-setting-btn"></button>
                <button id="pauseRestartButton" class="overlay-button main-setting-btn" data-lang-key="restart">重新開始</button>
                <button id="exitButton" class="overlay-button danger main-setting-btn" data-lang-key="exit">退出遊戲</button>
            </div>
        </div>
        <div id="countdownOverlay" class="hidden">3</div>
    </div>

    <script>
    // --- I18N (Internationalization) ---
    const TRANSLATIONS = {
        en: {
            langName: "English",
            pageTitle: "A Music Game (v2.0)", gameTitle: "A Music Game", back: "Back", backToMain: "Main Menu", combo: "Combo", level: "Level {level}",
            startScreenPrompt: "For the best experience, please click to start.", clickToStart: "Click to Start", audioError: "Failed to start audio. Please check browser settings or refresh.",
            mainMenuPrompt: "Choose your game mode!", classicModeButton: "Classic Mode", speedModeButton: "Speed Mode", otherButton: "Other",
            otherTitle: "Other", languageTitle: "Language", playerButton: "Player", saveDataButton: "Save Data", modeMenuButton: "Game Mode", vibrationMenuButton: "Vibration",
            playerTitle: "Player", playerLevel: "Level:", playerExp: "EXP:", playerMaxLevel: "MAX LEVEL", classicHistory: "Classic Mode History", speedHistory: "Speed Mode History", highScore: "High Score:", highRank: "High Rank:", playCount: "Plays:", highCombo: "High Combo:", highBpm: "High BPM:",
            saveDataTitle: "Save Management", saveDataPrompt: "Copy the key to back up, or paste a key to restore.", exportKey: "Export Key", importKey: "Import Key", exportSuccess: "Key copied to clipboard!", exportFail: "Failed to copy. Please copy manually.", importPrompt: "Please paste your save key:", importSuccess: "Save data imported!", importFail: "Import failed! Key is invalid or corrupted.", importConfirm: "Are you sure you want to overwrite current data? This action cannot be undone.",
            modeMenuTitle: "Game Mode", modeMenuPrompt: "Choose your preferred control method.", touchMode: "Mobile (Touch)", keyboardMode: "PC (Keyboard)", switchToTouch: "Switch to Mobile Mode", switchToKeyboard: "Switch to PC Mode",
            vibrationMenuTitle: "Vibration", vibrationMenuPrompt: "Choose your preferred vibration mode.", vibrationOnHit: "On Hit Only", vibrationFollowRhythm: "Follow Rhythm", off: "Off", weak: "Weak", strong: "Strong", moreInfo: "More Info", vibrationHelp: "Mostly supported on Android.\nNot supported on iOS/iPadOS/Windows/macOS.\nPlease disable silent mode.", vibrationNotSupported: "Vibration (Not Supported)",
            classicModeTitle: "Classic Mode", classicModePrompt: "Choose a song to begin!",
            speedModeTitle: "Speed Mode", speedModePrompt: "BPM will continuously increase. Challenge your limits!", speedFixed: "Fixed Challenge", speedRandom: "Random Challenge",
            pause: "Pause", pauseTitle: "Paused", resume: "Resume", restart: "Restart", exit: "Exit Game", exitConfirm: "Are you sure you want to exit?",
            gameOverTitleClassic: "Performance End", gameOverTitleSpeed: "Challenge Over", finalAccuracy: "Accuracy:", finalScore: "Score:", finalMaxCombo: "Max Combo:", finalBPM: "Max BPM:", expGained: "EXP Gained:",
            allPerfect: "All Perfect", fullCombo: "Full Combo",
            levelUpAlert: "Congratulations! You are now Level {level}!", unlockSong: "Congratulations! Unlocked song: \"{songName}\"!", unlockCondition: "Unlock Condition", unlockLevelRequirement: "Requires Level {level} to unlock.",
        },
        zh: {
            langName: "繁體中文",
            pageTitle: "音符醬 (v2.0)", gameTitle: "音符醬", back: "返回", backToMain: "返回主選單", combo: "連擊", level: "等級 {level}",
            startScreenPrompt: "為了最好的遊戲體驗，請點擊開始", clickToStart: "點擊以開始", audioError: "無法啟動音訊，請檢查瀏覽器設定或重整。",
            mainMenuPrompt: "選擇你的遊戲模式！", classicModeButton: "經典演奏模式", speedModeButton: "極限手速模式", otherButton: "其他",
            otherTitle: "其他", languageTitle: "語言", playerButton: "玩家", saveDataButton: "存檔管理", modeMenuButton: "遊戲模式", vibrationMenuButton: "震動設定",
            playerTitle: "玩家", playerLevel: "等級:", playerExp: "經驗值:", playerMaxLevel: "滿等", classicHistory: "經典演奏模式紀錄", speedHistory: "極限手速模式紀錄", highScore: "最高分:", highRank: "最高評級:", playCount: "遊玩次數:", highCombo: "最高 Combo:", highBpm: "最高 BPM:",
            saveDataTitle: "存檔管理", saveDataPrompt: "複製金鑰備份，或貼上金鑰還原紀錄。", exportKey: "匯出金鑰", importKey: "匯入金鑰", exportSuccess: "金鑰已複製到剪貼簿！", exportFail: "複製失敗，請手動複製。", importPrompt: "請貼上您的存檔金鑰：", importSuccess: "存檔匯入成功！", importFail: "匯入失敗！此金鑰損壞或無效。", importConfirm: "您確定要用這個存檔覆蓋目前的遊戲紀錄嗎？此操作無法復原。",
            modeMenuTitle: "遊戲模式", modeMenuPrompt: "選擇適合你的操作方式", touchMode: "手機觸控", keyboardMode: "電腦鍵盤", switchToTouch: "切換為手機模式", switchToKeyboard: "切換為電腦模式",
            vibrationMenuTitle: "震動設定", vibrationMenuPrompt: "選擇您偏好的震動模式", vibrationOnHit: "僅打擊時", vibrationFollowRhythm: "跟隨節奏", off: "關閉", weak: "弱", strong: "強", moreInfo: "更多說明", vibrationHelp: "Android系統大部分支援此模式。\niOS/iPadOS/Windows/macOS不支援。\n請關閉靜音模式。", vibrationNotSupported: "震動設定 (裝置不支援)",
            classicModeTitle: "經典演奏模式", classicModePrompt: "選擇一首歌曲開始挑戰！",
            speedModeTitle: "極限手速模式", speedModePrompt: "BPM將持續提升，挑戰你的極限！", speedFixed: "定點挑戰", speedRandom: "隨機挑戰",
            pause: "暫停", pauseTitle: "遊戲暫停", resume: "繼續遊戲", restart: "重新開始", exit: "退出遊戲", exitConfirm: "是否退出遊戲？",
            gameOverTitleClassic: "演奏結束", gameOverTitleSpeed: "挑戰結束", finalAccuracy: "最終精準度:", finalScore: "最終分數:", finalMaxCombo: "最高 Combo:", finalBPM: "最高 BPM:", expGained: "獲得經驗:",
            allPerfect: "All Perfect", fullCombo: "Full Combo",
            levelUpAlert: "恭喜升級！你現在是等級 {level}！", unlockSong: "恭喜！已解鎖新歌曲「{songName}」！", unlockCondition: "解鎖條件", unlockLevelRequirement: "需要達到等級 {level} 才能解鎖。",
        },
        'zh-CN': {
            langName: "简体中文",
            pageTitle: "音符酱 (v2.0)", gameTitle: "音符酱", back: "返回", backToMain: "返回主菜单", combo: "连击", level: "等级 {level}",
            startScreenPrompt: "为获得最佳体验，请点击开始", clickToStart: "点击以开始", audioError: "无法启动音频，请检查浏览器设置或刷新。",
            mainMenuPrompt: "选择你的游戏模式！", classicModeButton: "经典演奏模式", speedModeButton: "极限手速模式", otherButton: "其他",
            otherTitle: "其他", languageTitle: "语言", playerButton: "玩家", saveDataButton: "存档管理", modeMenuButton: "游戏模式", vibrationMenuButton: "振动设置",
            playerTitle: "玩家", playerLevel: "等级:", playerExp: "经验值:", playerMaxLevel: "满级", classicHistory: "经典模式记录", speedHistory: "极限手速记录", highScore: "最高分:", highRank: "最高评级:", playCount: "游玩次数:", highCombo: "最高连击:", highBpm: "最高BPM:",
            saveDataTitle: "存档管理", saveDataPrompt: "复制密钥备份，或粘贴密钥还原。", exportKey: "导出密钥", importKey: "导入密钥", exportSuccess: "密钥已复制到剪贴板！", exportFail: "复制失败，请手动复制。", importPrompt: "请输入您的存档密钥：", importSuccess: "存档导入成功！", importFail: "导入失败！密钥无效或损坏。", importConfirm: "您确定要覆盖当前数据吗？此操作无法撤销。",
            modeMenuTitle: "游戏模式", modeMenuPrompt: "选择你的操作方式", touchMode: "手机触控", keyboardMode: "电脑键盘", switchToTouch: "切换为手机模式", switchToKeyboard: "切换为电脑模式",
            vibrationMenuTitle: "振动设置", vibrationMenuPrompt: "选择您偏好的振动模式", vibrationOnHit: "仅打击时", vibrationFollowRhythm: "跟随节奏", off: "关闭", weak: "弱", strong: "强", moreInfo: "更多说明", vibrationHelp: "安卓系统大多支持此模式。\niOS/iPadOS/Windows/macOS不支持。\n请关闭静音模式。", vibrationNotSupported: "振动设置 (设备不支持)",
            classicModeTitle: "经典演奏模式", classicModePrompt: "选择一首歌曲开始挑战！",
            speedModeTitle: "极限手速模式", speedModePrompt: "BPM将持续提升，挑战你的极限！", speedFixed: "定点挑战", speedRandom: "随机挑战",
            pause: "暂停", pauseTitle: "游戏暂停", resume: "继续游戏", restart: "重新开始", exit: "退出游戏", exitConfirm: "确定退出吗？",
            gameOverTitleClassic: "演奏结束", gameOverTitleSpeed: "挑战结束", finalAccuracy: "最终准确度:", finalScore: "最终分数:", finalMaxCombo: "最高连击:", finalBPM: "最高BPM:", expGained: "获得经验:",
            allPerfect: "All Perfect", fullCombo: "Full Combo",
            levelUpAlert: "恭喜升级！你现在是等级 {level}！", unlockSong: "恭喜！已解锁新歌曲《{songName}》！", unlockCondition: "解锁条件", unlockLevelRequirement: "需要达到等级 {level} 才能解锁。",
        },
        ja: {
            langName: "日本語",
            pageTitle: "音楽ゲーム (v2.0)", gameTitle: "音楽ゲーム", back: "戻る", backToMain: "メインメニューへ", combo: "コンボ", level: "レベル {level}",
            startScreenPrompt: "最高の体験のために、クリックして開始してください。", clickToStart: "クリックして開始", audioError: "オーディオを開始できません。ブラウザの設定を確認するか、リフレッシュしてください。",
            mainMenuPrompt: "ゲームモードを選択してください！", classicModeButton: "クラシックモード", speedModeButton: "スピードモード", otherButton: "その他",
            otherTitle: "その他", languageTitle: "言語", playerButton: "プレイヤー", saveDataButton: "データ管理", modeMenuButton: "ゲームモード", vibrationMenuButton: "振動設定",
            playerTitle: "プレイヤー", playerLevel: "レベル:", playerExp: "経験値:", playerMaxLevel: "最大レベル", classicHistory: "クラシックモード記録", speedHistory: "スピードモード記録", highScore: "ハイスコア:", highRank: "最高ランク:", playCount: "プレイ回数:", highCombo: "最大コンボ:", highBpm: "最大BPM:",
            saveDataTitle: "データ管理", saveDataPrompt: "キーをコピーしてバックアップするか、キーを貼り付けて復元します。", exportKey: "エクスポート", importKey: "インポート", exportSuccess: "キーがクリップボードにコピーされました！", exportFail: "コピーに失敗しました。手動でコピーしてください。", importPrompt: "セーブキーを貼り付けてください：", importSuccess: "データが正常にインポートされました！", importFail: "インポートに失敗しました！キーが無効か破損しています。", importConfirm: "現在のデータを上書きしますか？この操作は元に戻せません。",
            modeMenuTitle: "ゲームモード", modeMenuPrompt: "操作方法を選択してください", touchMode: "モバイル (タッチ)", keyboardMode: "PC (キーボード)", switchToTouch: "モバイルモードに切替", switchToKeyboard: "PCモードに切替",
            vibrationMenuTitle: "振動設定", vibrationMenuPrompt: "振動モードを選択してください", vibrationOnHit: "ヒット時のみ", vibrationFollowRhythm: "リズムに合わせる", off: "オフ", weak: "弱", strong: "強", moreInfo: "詳細", vibrationHelp: "主にAndroidでサポートされています。\niOS/iPadOS/Windows/macOSではサポートされていません。\nサイレントモードをオフにしてください。", vibrationNotSupported: "振動 (非対応)",
            classicModeTitle: "クラシックモード", classicModePrompt: "曲を選んで挑戦しよう！",
            speedModeTitle: "スピードモード", speedModePrompt: "BPMが上がり続けます。限界に挑戦！", speedFixed: "固定チャレンジ", speedRandom: "ランダムチャレンジ",
            pause: "一時停止", pauseTitle: "一時停止中", resume: "再開", restart: "リスタート", exit: "終了", exitConfirm: "ゲームを終了しますか？",
            gameOverTitleClassic: "演奏終了", gameOverTitleSpeed: "チャレンジ終了", finalAccuracy: "最終精度:", finalScore: "最終スコア:", finalMaxCombo: "最大コンボ:", finalBPM: "最大BPM:", expGained: "獲得経験値:",
            allPerfect: "オールパーフェクト", fullCombo: "フルコンボ",
            levelUpAlert: "レベルアップ！レベル {level}になりました！", unlockSong: "おめでとうございます！新しい曲「{songName}」がアンロックされました！", unlockCondition: "アンロック条件", unlockLevelRequirement: "アンロックするにはレベル {level} が必要です。",
        },
        ko: {
            langName: "한국어",
            pageTitle: "음악 게임 (v2.0)", gameTitle: "음악 게임", back: "뒤로", backToMain: "메인 메뉴로", combo: "콤보", level: "레벨 {level}",
            startScreenPrompt: "최상의 경험을 위해 클릭하여 시작하세요.", clickToStart: "클릭하여 시작", audioError: "오디오를 시작할 수 없습니다. 브라우저 설정을 확인하거나 새로고침하세요.",
            mainMenuPrompt: "게임 모드를 선택하세요!", classicModeButton: "클래식 모드", speedModeButton: "스피드 모드", otherButton: "기타",
            otherTitle: "기타", languageTitle: "언어", playerButton: "플레이어", saveDataButton: "데이터 관리", modeMenuButton: "게임 모드", vibrationMenuButton: "진동 설정",
            playerTitle: "플레이어", playerLevel: "레벨:", playerExp: "경험치:", playerMaxLevel: "최대 레벨", classicHistory: "클래식 모드 기록", speedHistory: "스피드 모드 기록", highScore: "최고 점수:", highRank: "최고 등급:", playCount: "플레이 횟수:", highCombo: "최대 콤보:", highBpm: "최대 BPM:",
            saveDataTitle: "데이터 관리", saveDataPrompt: "키를 복사하여 백업하거나, 키를 붙여넣어 복원하세요.", exportKey: "내보내기", importKey: "가져오기", exportSuccess: "키가 클립보드에 복사되었습니다!", exportFail: "복사에 실패했습니다. 수동으로 복사해주세요.", importPrompt: "세이브 키를 붙여넣으세요:", importSuccess: "데이터를 성공적으로 가져왔습니다!", importFail: "가져오기 실패! 키가 유효하지 않거나 손상되었습니다。", importConfirm: "현재 데이터를 덮어쓰시겠습니까? 이 작업은 되돌릴 수 없습니다.",
            modeMenuTitle: "게임 모드", modeMenuPrompt: "선호하는 조작 방식을 선택하세요.", touchMode: "모바일 (터치)", keyboardMode: "PC (키보드)", switchToTouch: "모바일 모드로 전환", switchToKeyboard: "PC 모드로 전환",
            vibrationMenuTitle: "진동 설정", vibrationMenuPrompt: "선호하는 진동 모드를 선택하세요.", vibrationOnHit: "히트 시에만", vibrationFollowRhythm: "리듬에 맞춰", off: "끄기", weak: "약하게", strong: "강하게", moreInfo: "추가 정보", vibrationHelp: "주로 안드로이드에서 지원됩니다.\niOS/iPadOS/Windows/macOS에서는 지원되지 않습니다.\n무음 모드를 비활성화하세요.", vibrationNotSupported: "진동 (미지원)",
            classicModeTitle: "클래식 모드", classicModePrompt: "도전할 곡을 선택하세요!",
            speedModeTitle: "스피드 모드", speedModePrompt: "BPM이 계속 증가합니다. 한계에 도전하세요!", speedFixed: "고정 챌린지", speedRandom: "랜덤 챌린지",
            pause: "일시정지", pauseTitle: "일시정지됨", resume: "계속하기", restart: "다시 시작", exit: "나가기", exitConfirm: "게임을 종료하시겠습니까?",
            gameOverTitleClassic: "연주 종료", gameOverTitleSpeed: "도전 종료", finalAccuracy: "최종 정확도:", finalScore: "최종 점수:", finalMaxCombo: "최대 콤보:", finalBPM: "최대 BPM:", expGained: "획득 경험치:",
            allPerfect: "올 퍼펙트", fullCombo: "풀 콤보",
            levelUpAlert: "레벨 업! 이제 레벨 {level}입니다!", unlockSong: "축하합니다! 새로운 곡 '{songName}'이 잠금 해제되었습니다!", unlockCondition: "잠금 해제 조건", unlockLevelRequirement: "잠금을 해제하려면 레벨 {level}이 필요합니다.",
        }
    };
    
    // --- Constants and Game Data ---
    const CONSTANTS = {
        LANE_COUNT: 4,
        FALL_TIME_SECONDS: 1.8,
        HIT_LINE_Y_RATIO: 0.7,
        PERFECT_THRESHOLD: 0.08,
        GOOD_THRESHOLD: 0.16,
        LANE_COLORS: ['#f87171', '#fb923c', '#a78bfa', '#60a5fa'],
        RANK_ORDER: ['D', 'C-', 'C', 'C+', 'B-', 'B', 'B+', 'A-', 'A', 'A+', 'S-', 'S', 'S+', 'S++'],
        PLAYER_DATA_KEY: 'noteSaucePlayerData_v2',
        CURRENT_VERSION: 3,
        MAX_LEVEL: 6,
    };

    const SONG_LIBRARY = {
        twinkle: { 
            name: { en: "Twinkle Twinkle", zh: "小星星", 'zh-CN': '小星星', ja: 'きらきら星', ko: '반짝반짝 작은 별' }, 
            bpm: 100, 
            beatmap: [ [1,0,"C4"], [2,0,"C4"], [3,2,"G4"], [4,2,"G4"], [5,2,"A4"], [6,2,"A4"], [7,2,"G4"], [9,1,"F4"], [10,1,"F4"], [11,1,"E4"], [12,1,"E4"], [13,0,"D4"], [14,0,"D4"], [15,0,"C4"], [17,2,"G4"], [18,2,"G4"], [19,1,"F4"], [20,1,"F4"], [21,1,"E4"], [22,1,"E4"], [23,0,"D4"], [25,2,"G4"], [26,2,"G4"], [27,1,"F4"], [28,1,"F4"], [29,1,"E4"], [30,1,"E4"], [31,0,"D4"], [33,0,"C4"], [34,0,"C4"], [35,2,"G4"], [36,2,"G4"], [37,2,"A4"], [38,2,"A4"], [39,2,"G4"], [41,1,"F4"], [42,1,"F4"], [43,1,"E4"], [44,1,"E4"], [45,0,"D4"], [46,0,"D4"], [47,0,"C4"], ] 
        },
        butterfly: { 
            name: { en: "Butterfly", zh: "蝴蝶", 'zh-CN': '蝴蝶', ja: '蝶々', ko: '나비' }, 
            unlockLevel: 2, // <-- Changed from 3 to 2
            bpm: 100, 
            beatmap: [ [1.0, 0, "C4"], [2.0, 0, "C4"], [2.5, 0, "D4"], [3.0, 1, "E4"], [4.0, 1, "E4"], [5.0, 0, "D4"], [5.5, 0, "C4"], [6.0, 0, "D4"], [6.5, 1, "E4"], [7.0, 0, "C4"], [9.0, 1, "E4"], [10.0, 1, "F4"], [11.0, 2, "G4"], [12.0, 2, "G4"], [13.0, 1, "F4"], [13.5, 1, "E4"], [14.0, 1, "F4"], [14.5, 2, "G4"], [15.0, 1, "E4"], [17.0, 0, "C5"], [18.0, 3, "B4"], [19.0, 2, "A4"], [20.0, 2, "G4"], [21.0, 1, "E4"], [22.0, 0, "C5"], [23.0, 3, "B4"], [24.0, 2, "A4"], [25.0, 2, "G4"], [26.0, 2, "A4"], [27.0, 3, "B4"], [28.0, 0, "C5"], [29.0, 2, "G4"], [31.0, 1, "E4"] ] 
        },
        furElise: { 
            name: { en: "For Elise", zh: "給愛麗絲", 'zh-CN': '致爱丽丝', ja: 'エリーゼのために', ko: '엘리제를 위하여' }, 
            unlockLevel: 6,
            bpm: 120, 
            beatmap: [ [1.0, 3, "E5"], [1.5, 2, "Ds5"], [2.0, 3, "E5"], [2.5, 2, "Ds5"], [3.0, 3, "E5"], [3.5, 1, "B4"], [4.0, 2, "D5"], [4.5, 0, "C5"], [5.0, 2, "A4"], [5.0, 0, "A3"], [6.0, 0, "C4"], [6.5, 1, "E4"], [7.0, 2, "A4"], [7.5, 1, "B4"], [7.5, 0, "E3"], [9.0, 1, "E4"], [9.0, 0, "G3"], [9.5, 2, "Gs4"], [10.0, 3, "B4"], [10.5, 0, "C5"], [10.5, 0, "A3"], [11.5, 3, "E5"], [12.0, 2, "Ds5"], [12.5, 3, "E5"], [13.0, 2, "Ds5"], [13.5, 3, "E5"], [14.0, 1, "B4"], [14.5, 2, "D5"], [15.0, 0, "C5"], [15.5, 2, "A4"], [15.5, 0, "A3"], [17.0, 0, "C4"], [17.5, 1, "E4"], [18.0, 2, "A4"], [18.5, 1, "B4"], [18.5, 0, "E3"], [20.0, 1, "E4"], [20.0, 0, "G3"], [20.5, 0, "C5"], [21.0, 3, "B4"], [21.5, 2, "A4"], [21.5, 0, "A2"], [23.0, 3, "E5"], [23.5, 2, "Ds5"], [24.0, 3, "E5"], [24.5, 2, "Ds5"], [25.0, 3, "E5"], [25.5, 1, "B4"], [26.0, 2, "D5"], [26.5, 0, "C5"], [27.0, 2, "A4"], [27.0, 0, "A3"], [28.0, 0, "C4"], [28.5, 1, "E4"], [29.0, 2, "A4"], [29.5, 1, "B4"], [29.5, 0, "E3"], [31.0, 0, "C5"], [31.5, 2, "G4"], [32.0, 1, "F4"], [32.5, 3, "E5"], [32.5, 1, "E4"], [33.5, 2, "D5"], [34.0, 1, "C5"], [34.5, 2, "B4"], [34.5, 0, "G3"], [35.5, 2, "E4"], [36.0, 3, "E5"], [36.5, 2, "E4"], [37.0, 3, "E5"], [37.5, 2, "Ds5"]]}
    };

    const SPEED_MODE_CONFIG = {
        fixed: { unlockLevel: 4 },
        random: { unlockLevel: 5 },
    };

    /**
     * LanguageManager: Handles all language-related tasks
     */
    class LanguageManager {
        constructor(gameInstance) {
            this.game = gameInstance;
            this.currentLanguage = 'zh'; // Default language
            this.languageDrawers = document.querySelectorAll('.language-drawer');
        }

        init() {
            const savedLang = this.game.playerData.playerData.language;
            const browserLangMatch = navigator.language;
            let defaultLang = 'en';
            if (browserLangMatch.startsWith('zh-CN')) defaultLang = 'zh-CN';
            else if (browserLangMatch.startsWith('zh')) defaultLang = 'zh';
            else if (browserLangMatch.startsWith('ja')) defaultLang = 'ja';
            else if (browserLangMatch.startsWith('ko')) defaultLang = 'ko';

            this.setLanguage(savedLang || defaultLang, false);

            this.languageDrawers.forEach(drawer => {
                drawer.querySelectorAll('button[data-lang]').forEach(button => {
                    button.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent the drawer from closing and re-opening
                        this.setLanguage(e.currentTarget.dataset.lang);
                        drawer.removeAttribute('open'); // Close drawer after selection
                    });
                });
            });
        }

        get(key, replacements = {}) {
            const langMap = TRANSLATIONS[this.currentLanguage] || TRANSLATIONS.en;
            let text = langMap[key] || TRANSLATIONS.en[key] || `[${key}]`;
            for (const placeholder in replacements) {
                text = text.replace(`{${placeholder}}`, replacements[placeholder]);
            }
            return text;
        }

        setLanguage(lang, fromUserAction = true) {
            this.currentLanguage = lang;
            document.documentElement.lang = lang;
            
            if (fromUserAction) {
                this.game.playerData.playerData.language = lang;
                this.game.playerData.save();
            }

            this.updateUI();
        }

        updateUI() {
            // Update all elements with data-lang-key
            document.querySelectorAll('[data-lang-key]').forEach(el => {
                const key = el.dataset.langKey;
                el.textContent = this.get(key);
            });

            // Update specific elements that need more logic
            document.title = this.get('pageTitle');
            this.game.ui.updateAllUnlocks(this.game.playerData.playerData);
            this.game.ui.updateKeyLabels(this.game.inputMode);
            this.game.ui.displayPlayerPage(this.game.playerData.playerData);

            // Update language drawer buttons
            this.languageDrawers.forEach(drawer => {
                const summaryBtn = drawer.querySelector('summary');
                if (summaryBtn) {
                    summaryBtn.textContent = this.get('langName');
                }
                drawer.querySelectorAll('button[data-lang]').forEach(button => {
                    button.classList.toggle('active', button.dataset.lang === this.currentLanguage);
                });
            });
            
            // Update vibration button text if not supported
            if (!this.game.supportsVibration) {
                 this.game.ui.dom.vibrationMenuButton.textContent = this.get('vibrationNotSupported');
            }
        }
    }
    
    /**
     * AudioManager: Manages all audio-related tasks using Tone.js
     */
    class AudioManager {
        constructor() {
            this.hitSynth = null;
            this.metronomeEvent = null;
            this.isReady = false;
        }

        async init() {
            if (this.isReady) return;
            await Tone.start();
            this.hitSynth = new Tone.Synth({ oscillator: { type: 'square' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination();
            this.isReady = true;
            console.log("AudioContext is ready.");
        }

        playNote(pitch) {
            if (!this.isReady || !pitch) return;
            this.hitSynth.triggerAttackRelease(pitch, '8n', Tone.now());
        }

        startTransport(bpm, vibrationCallback) {
            if (!this.isReady) return;
            Tone.Transport.bpm.value = bpm;
            if (vibrationCallback) {
                this.metronomeEvent = Tone.Transport.scheduleRepeat(() => {
                    vibrationCallback();
                }, '4n');
            }
            Tone.Transport.position = 0;
            Tone.Transport.start();
        }

        stopAndReset() {
            Tone.Transport.stop();
            Tone.Transport.cancel(0);
            if (this.metronomeEvent) {
                this.metronomeEvent.dispose();
                this.metronomeEvent = null;
            }
        }
        
        pause() { Tone.Transport.pause(); }
        resume() { Tone.Transport.start(); }

        getCurrentTime() { return this.isReady ? Tone.Transport.seconds : 0; }
        
        setBPM(bpm) { if(this.isReady) Tone.Transport.bpm.value = bpm; }
    }

    /**
     * UIManager: Handles all DOM manipulations and rendering
     */
    class UIManager {
        constructor(gameInstance) {
            this.game = gameInstance;
            this.ctx = null;
            this.dom = {};
            this.laneWidth = 0;
            this.hitLineY = 0;
            this.feedbackTimeout = null;
        }
        
        init() {
            this.cacheDOMElements();
            this.ctx = this.dom.gameCanvas.getContext('2d');
        }

        cacheDOMElements() {
            const ids = [
                'gameCanvas', 'scoreDisplay', 'comboDisplay', 'bpmDisplay', 'hitFeedback', 'startScreen', 'mainMenu', 'classicMenu', 
                'speedMenu', 'otherMenu', 'modePopupMenu', 'vibrationPopupMenu', 'playerScreen', 'saveDataScreen', 'gameOverScreen', 'pauseOverlay', 
                'countdownOverlay', 'progressBar', 'progressBarContainer', 'pauseButton', 'startButton', 'classicModeButton', 
                'speedModeButton', 'otherButton', 'playerButton', 'saveDataButton', 'modeMenuButton', 'vibrationMenuButton', 
                'vibrationHelpBtn', 'touchModeBtn', 'keyboardModeBtn', 'resumeButton', 'modeSwitchButton', 'pauseRestartButton', 
                'exitButton', 'saveDataKey', 'exportSaveData', 'importSaveData', 'playerStatsContainer', 'historyContent', 
                'gameOverTitle', 'rankDisplayContainer', 'rankDisplay', 'achievementDisplay', 'finalAccuracy', 'finalScore', 
                'perfectCount', 'goodCount', 'missCount', 'finalMaxCombo', 'finalBpmLabel', 'finalBPM', 'expGained'
            ];
            
            ids.forEach(id => this.dom[id] = document.getElementById(id));
            
            this.dom.keyButtons = document.querySelectorAll('.key-button');
            this.dom.keyLabels = document.querySelectorAll('.key-label');
            this.dom.vibrationButtons = document.querySelectorAll('[data-vibration]');
            this.dom.backButtons = document.querySelectorAll('.back-button');
            this.dom.homeButtons = document.querySelectorAll('.home-button');
            this.dom.classicSongButtons = document.querySelectorAll('#classicMenu [data-song]');
            this.dom.speedModeButtons = document.querySelectorAll('#speedMenu [data-speed-mode]');
        }

        resize(wrapper) {
            const TARGET_RATIO = 9 / 16;
            const availableWidth = window.innerWidth;
            const availableHeight = window.innerHeight;
            const windowRatio = availableWidth / availableHeight;
            let newWidth, newHeight;
            if (windowRatio > TARGET_RATIO) {
                newHeight = availableHeight;
                newWidth = newHeight * TARGET_RATIO;
            } else {
                newWidth = availableWidth;
                newHeight = newWidth / TARGET_RATIO;
            }
            wrapper.style.width = `${newWidth}px`;
            wrapper.style.height = `${newHeight}px`;
            this.dom.gameCanvas.width = newWidth;
            this.dom.gameCanvas.height = newHeight;
            this.laneWidth = this.dom.gameCanvas.width / CONSTANTS.LANE_COUNT;
            this.hitLineY = this.dom.gameCanvas.height * CONSTANTS.HIT_LINE_Y_RATIO;
        }
        
        showScreen(screenName) {
            ['startScreen', 'mainMenu', 'classicMenu', 'speedMenu', 'otherMenu', 'modePopupMenu', 
             'vibrationPopupMenu', 'playerScreen', 'saveDataScreen', 'gameOverScreen', 'pauseOverlay', 'countdownOverlay']
            .forEach(name => {
                if(this.dom[name]) this.dom[name].classList.add('hidden');
            });
            if (this.dom[screenName]) {
                this.dom[screenName].classList.remove('hidden');
                // When showing player screen, explicitly update its content
                if (screenName === 'playerScreen') {
                    this.displayPlayerPage(this.game.playerData.playerData);
                }
            }
        }
        
        updateInGameUI(stats) {
            this.dom.scoreDisplay.textContent = stats.score;
            this.dom.comboDisplay.textContent = stats.combo > 1 ? `${this.game.lang.get('combo')} ${stats.combo}` : '';
            if (stats.combo > 1) {
                this.dom.comboDisplay.style.transform = 'scale(1.2)';
                setTimeout(() => this.dom.comboDisplay.style.transform = 'scale(1)', 100);
            }
            if(stats.bpm) {
                this.dom.bpmDisplay.classList.remove('hidden');
                this.dom.bpmDisplay.textContent = `BPM: ${Math.floor(stats.bpm)}`;
            } else {
                this.dom.bpmDisplay.classList.add('hidden');
            }
            this.dom.progressBar.style.width = `${stats.progress * 100}%`;
            this.dom.progressBarContainer.style.display = stats.showProgressBar ? 'block' : 'none';
            this.dom.pauseButton.classList.toggle('hidden', !stats.showPause);
        }

        resetInGameUI() {
            this.updateInGameUI({ score: 0, combo: 0, progress: 0, showPause: false, showProgressBar: false});
        }

        showHitFeedback(type) {
            const textMap = { perfect: 'PERFECT', good: 'GOOD', miss: 'MISS' };
            this.dom.hitFeedback.textContent = textMap[type];
            this.dom.hitFeedback.className = `hit-feedback show ${type}`;
            if (this.feedbackTimeout) clearTimeout(this.feedbackTimeout);
            this.feedbackTimeout = setTimeout(() => this.dom.hitFeedback.classList.remove('show'), 300);
        }
        
        draw(notes) {
            this.ctx.clearRect(0, 0, this.dom.gameCanvas.width, this.dom.gameCanvas.height);
            for (let i = 0; i < CONSTANTS.LANE_COUNT; i++) {
                this.ctx.fillStyle = (i % 2 === 0) ? '#1f2937' : '#374151';
                this.ctx.fillRect(i * this.laneWidth, 0, this.laneWidth, this.dom.gameCanvas.height);
            }
            this.ctx.fillStyle = '#a78bfa';
            this.ctx.fillRect(0, this.hitLineY - 2, this.dom.gameCanvas.width, 4);
            for (const note of notes) {
                if (note.y > -50 && note.y < this.dom.gameCanvas.height + 50) {
                    this.ctx.fillStyle = CONSTANTS.LANE_COLORS[note.lane];
                    this.ctx.fillRect(note.lane * this.laneWidth + 5, note.y - 10, this.laneWidth - 10, 20);
                }
            }
        }
        
        showCountdown(count, callback) {
            this.showScreen('countdownOverlay');
            this.dom.countdownOverlay.textContent = count;
            const interval = setInterval(() => {
                count--;
                if (count > 0) {
                    this.dom.countdownOverlay.textContent = count;
                } else {
                    clearInterval(interval);
                    this.showScreen('none');
                    callback();
                }
            }, 1000);
        }
        
        showGameOver(results) {
            this.dom.gameOverTitle.textContent = results.title;
            this.dom.finalAccuracy.textContent = `${results.accuracy.toFixed(2)}%`;
            this.dom.finalScore.textContent = results.score;
            this.dom.perfectCount.textContent = results.counts.perfect;
            this.dom.goodCount.textContent = results.counts.good;
            this.dom.missCount.textContent = results.counts.miss;
            this.dom.finalMaxCombo.textContent = results.maxCombo;
            this.dom.expGained.textContent = `+${results.expGained}`;
            
            this.dom.rankDisplayContainer.style.display = results.rank ? 'block' : 'none';
            if(results.rank) {
                this.dom.rankDisplay.textContent = results.rank;
                let rankClass = 'rank-d';
                if (results.rank.startsWith('S')) rankClass = 'rank-s'; else if (results.rank.startsWith('A')) rankClass = 'rank-a'; else if (results.rank.startsWith('B')) rankClass = 'rank-b'; else if (results.rank.startsWith('C')) rankClass = 'rank-c';
                this.dom.rankDisplay.className = rankClass;
            }
            
            this.dom.achievementDisplay.textContent = results.achievement.text;
            this.dom.achievementDisplay.className = results.achievement.class;
            
            this.dom.finalBpmLabel.style.display = results.maxBPM ? 'block' : 'none';
            this.dom.finalBPM.style.display = results.maxBPM ? 'block' : 'none';
            if (results.maxBPM) {
                this.dom.finalBPM.textContent = results.maxBPM;
            }
            
            this.showScreen('gameOverScreen');
        }

        updateKeyLabels(mode) {
            this.dom.keyLabels.forEach(label => label.style.opacity = (mode === 'keyboard') ? '1' : '0');
            const switchKey = (mode === 'keyboard') ? 'switchToTouch' : 'switchToKeyboard';
            this.dom.modeSwitchButton.textContent = this.game.lang.get(switchKey);
        }

        updateVibrationButtons(vibrationMode) {
             this.dom.vibrationButtons.forEach(btn => {
                btn.classList.toggle('secondary', btn.dataset.vibration !== vibrationMode);
            });
        }
        
        updateModeButtons(inputMode) {
            this.dom.touchModeBtn.classList.toggle('secondary', inputMode !== 'touch');
            this.dom.keyboardModeBtn.classList.toggle('secondary', inputMode !== 'keyboard');
        }
        
        updateAllUnlocks(playerData) {
            const lang = this.game.lang;
            const currentLang = lang.currentLanguage;

            const setupButton = (button, isUnlocked, unlockLevel, startFn) => {
                // To prevent event listener stacking, clone the button and replace it
                const newButton = button.cloneNode(true);
                button.parentNode.replaceChild(newButton, button);

                newButton.classList.toggle('locked', !isUnlocked);
                
                if (isUnlocked) {
                    newButton.addEventListener('click', startFn);
                } else {
                    newButton.addEventListener('click', (e) => {
                        e.preventDefault();
                        if (unlockLevel) {
                            alert(lang.get('unlockLevelRequirement', { level: unlockLevel }));
                        }
                    });
                }
                return newButton;
            };

            // Re-select buttons as they might be replaced
            this.dom.classicSongButtons = document.querySelectorAll('#classicMenu [data-song]');
            this.dom.classicSongButtons.forEach(button => {
                const songId = button.dataset.song;
                const songData = playerData.songs[songId];
                const songInfo = SONG_LIBRARY[songId];
                const isUnlocked = songData.unlocked;
                
                let buttonText = songInfo.name[currentLang];
                if (!isUnlocked && songInfo.unlockLevel) {
                    buttonText += ` (${lang.get('level', { level: songInfo.unlockLevel })})`;
                }
                button.textContent = buttonText;
                
                setupButton(button, isUnlocked, songInfo.unlockLevel, () => this.game.startClassicGame(songId));
            });

            this.dom.speedModeButtons = document.querySelectorAll('#speedMenu [data-speed-mode]');
            this.dom.speedModeButtons.forEach(button => {
                const modeType = button.dataset.speedMode;
                const modeConfig = SPEED_MODE_CONFIG[modeType];
                const isUnlocked = playerData.level >= modeConfig.unlockLevel;
                
                let buttonText = lang.get(button.dataset.langKey);
                if (!isUnlocked) {
                    buttonText += ` (${lang.get('level', { level: modeConfig.unlockLevel })})`;
                }
                button.textContent = buttonText;
                
                setupButton(button, isUnlocked, modeConfig.unlockLevel, () => this.game.startSpeedGame(modeType));
            });
        }
        
        displayPlayerPage(playerData) {
            if (this.dom.playerScreen.classList.contains('hidden')) {
                return;
            }

            let xpDisplayHTML;
            let xpBarHTML;
            const lang = this.game.lang;

            if (playerData.level >= CONSTANTS.MAX_LEVEL) {
                xpDisplayHTML = `<span class="stat-value" style="color: #f59e0b;">${lang.get('playerMaxLevel')}</span>`;
                xpBarHTML = `<div class="xp-bar-container"><div class="xp-bar" style="width: 100%; background-color: #f59e0b;"></div></div>`;
            } else {
                const xpPercent = (playerData.exp / playerData.expToNextLevel) * 100;
                xpDisplayHTML = `<span class="stat-value">${playerData.exp} / ${playerData.expToNextLevel}</span>`;
                xpBarHTML = `<div class="xp-bar-container"><div class="xp-bar" style="width: ${xpPercent}%"></div></div>`;
            }
            this.dom.playerStatsContainer.innerHTML = `<div class="player-stats"><div class="stat-item"><span class="stat-label">${lang.get('playerLevel')} </span><span class="stat-value">${playerData.level}</span></div><div class="stat-item"><span class="stat-label">${lang.get('playerExp')} </span>${xpDisplayHTML}</div>${xpBarHTML}</div>`;
            
            this.dom.historyContent.innerHTML = '';
            // Classic Mode History
            const classicDetails = document.createElement('details');
            classicDetails.innerHTML = `<summary>${lang.get('classicHistory')}</summary><div class="history-details"></div>`;
            const classicHistoryContainer = classicDetails.querySelector('.history-details');
            Object.keys(playerData.songs).forEach(songId => {
                const songData = playerData.songs[songId];
                if (!songData) return;
                const songInfo = SONG_LIBRARY[songId];
                let achievementText = songData.ap ? `<span class="achievement-ap">${lang.get('allPerfect')}</span>` : (songData.fc ? `<span class="achievement-fc">${lang.get('fullCombo')}</span>` : '');
                classicHistoryContainer.innerHTML += `<div class="history-entry"><div class="song-title">${songInfo.name[lang.currentLanguage]} ${achievementText}</div><div class="song-stats"><span class="stat-label">${lang.get('highScore')}</span> <span class="stat-value">${songData.highScore}</span><span class="stat-label">${lang.get('highRank')}</span> <span class="stat-value">${songData.highRank}</span><span class="stat-label">${lang.get('playCount')}</span> <span class="stat-value">${songData.playCount}</span></div></div>`;
            });
            this.dom.historyContent.appendChild(classicDetails);

            // Speed Mode History
            if (playerData.speedMode) {
                const speedDetails = document.createElement('details');
                speedDetails.innerHTML = `<summary>${lang.get('speedHistory')}</summary><div class="history-details"></div>`;
                const speedHistoryContainer = speedDetails.querySelector('.history-details');
                const modeNames = { fixed: lang.get('speedFixed'), random: lang.get('speedRandom') };
                Object.keys(playerData.speedMode).forEach(modeType => {
                    const modeData = playerData.speedMode[modeType];
                    if (!modeData) return;
                    speedHistoryContainer.innerHTML += `<div class="history-entry"><div class="song-title">${modeNames[modeType]}</div><div class="song-stats"><span class="stat-label">${lang.get('highCombo')}</span> <span class="stat-value">${modeData.highCombo}</span><span class="stat-label">${lang.get('highBpm')}</span> <span class="stat-value">${modeData.highBpm}</span><span class="stat-label">${lang.get('playCount')}</span> <span class="stat-value">${modeData.playCount}</span></div></div>`;
                });
                this.dom.historyContent.appendChild(speedDetails);
            }
        }
    }

    /**
     * PlayerDataManager: Manages loading, saving, and updating player data
     */
    class PlayerDataManager {
        constructor(gameInstance) {
            this.game = gameInstance;
            this.playerData = this.load();
        }

        getDefaultData() {
            return {
                version: CONSTANTS.CURRENT_VERSION, level: 1, exp: 0, expToNextLevel: 50, vibrationMode: 'off', inputMode: 'touch', language: 'zh',
                songs: { 'twinkle': { highScore: 0, highRank: 'D', playCount: 0, ap: false, fc: false, unlocked: true }, 'butterfly': { highScore: 0, highRank: 'D', playCount: 0, unlocked: false, ap: false, fc: false }, 'furElise': { highScore: 0, highRank: 'D', playCount: 0, unlocked: false, ap: false, fc: false }},
                speedMode: { fixed: { highCombo: 0, highBpm: 0, playCount: 0 }, random: { highCombo: 0, highBpm: 0, playCount: 0 }}
            };
        }
        
        load() {
            try {
                const savedJSON = localStorage.getItem(CONSTANTS.PLAYER_DATA_KEY);
                if (savedJSON) {
                    let savedData = JSON.parse(savedJSON);
                    return { ...this.getDefaultData(), ...savedData };
                }
            } catch (e) {
                console.error("Failed to load player data, resetting.", e);
                localStorage.removeItem(CONSTANTS.PLAYER_DATA_KEY);
            }
            return this.getDefaultData();
        }

        save() {
            try {
                this.playerData.version = CONSTANTS.CURRENT_VERSION;
                localStorage.setItem(CONSTANTS.PLAYER_DATA_KEY, JSON.stringify(this.playerData));
            } catch (e) {
                console.error("Failed to save player data.", e);
            }
        }

        addExp(amount) {
            if (this.playerData.level >= CONSTANTS.MAX_LEVEL) return;
            this.playerData.exp += amount;
            let leveledUp = false;
            while (this.playerData.exp >= this.playerData.expToNextLevel && this.playerData.level < CONSTANTS.MAX_LEVEL) {
                leveledUp = true;
                this.playerData.exp -= this.playerData.expToNextLevel;
                this.playerData.level++;
                if (this.playerData.level < CONSTANTS.MAX_LEVEL) {
                    this.playerData.expToNextLevel = Math.floor(this.playerData.expToNextLevel * 1.2 + 50);
                } else {
                    this.playerData.exp = 0;
                    this.playerData.expToNextLevel = 0;
                }
            }
            if (leveledUp) {
                alert(this.game.lang.get('levelUpAlert', {level: this.playerData.level}));
            }
            this.checkUnlocks(true);
            this.save();
        }
        
        checkUnlocks(isAfterLevelUp = false) {
             if (!this.playerData.songs.butterfly.unlocked && this.playerData.level >= SONG_LIBRARY.butterfly.unlockLevel) {
                this.playerData.songs.butterfly.unlocked = true;
                if(isAfterLevelUp) alert(this.game.lang.get('unlockSong', { songName: SONG_LIBRARY.butterfly.name[this.game.lang.currentLanguage] }));
            }
            if (!this.playerData.songs.furElise.unlocked && this.playerData.level >= SONG_LIBRARY.furElise.unlockLevel) {
                 this.playerData.songs.furElise.unlocked = true;
                 if(isAfterLevelUp) alert(this.game.lang.get('unlockSong', { songName: SONG_LIBRARY.furElise.name[this.game.lang.currentLanguage] }));
            }
        }
        
        updateClassicScore(songId, score, rank, counts) {
            const songData = this.playerData.songs[songId];
            if (!songData) return { text: '', class: '' };
            songData.playCount++;
            if (score > songData.highScore) songData.highScore = score;
            if (CONSTANTS.RANK_ORDER.indexOf(rank) > CONSTANTS.RANK_ORDER.indexOf(songData.highRank)) songData.highRank = rank;
            
            const isFC = counts.miss === 0 && (counts.perfect + counts.good) > 0;
            const isAP = isFC && counts.good === 0;
            
            let achievement = { text: '', class: ''};
            if (isAP) {
                songData.ap = true;
                achievement = { text: this.game.lang.get('allPerfect'), class: 'achievement-ap' };
            } else if (isFC) {
                songData.fc = true;
                achievement = { text: this.game.lang.get('fullCombo'), class: 'achievement-fc' };
            }
            this.save();
            return achievement;
        }
        
        updateSpeedScore(modeType, maxCombo, maxBPM) {
            const speedData = this.playerData.speedMode[modeType];
            if (speedData) {
                speedData.playCount++;
                if (maxCombo > speedData.highCombo) speedData.highCombo = maxCombo;
                if (maxBPM > speedData.highBpm) speedData.highBpm = maxBPM;
                this.save();
            }
        }

        getExportKey() {
            try {
                const dataString = JSON.stringify(this.playerData);
                return btoa(encodeURIComponent(dataString));
            } catch (e) {
                console.error('Export failed:', e);
                return null;
            }
        }

        importFromKey(key) {
            try {
                const decodedString = decodeURIComponent(atob(key));
                const importedData = JSON.parse(decodedString);
                if (!importedData || typeof importedData.level === 'undefined') {
                    throw new Error('Invalid key format');
                }
                if(confirm(this.game.lang.get('importConfirm'))) {
                    this.playerData = { ...this.getDefaultData(), ...importedData };
                    this.save();
                    return true;
                }
                return false;
            } catch (e) {
                console.error('Import failed:', e);
                return false;
            }
        }
    }

    /**
     * Game: The main class that orchestrates everything
     */
    class Game {
        constructor() {
            this.state = 'UNINITIALIZED'; // UNINITIALIZED, READY, COUNTDOWN, PLAYING, PAUSED, GAMEOVER
            this.lang = new LanguageManager(this);
            this.ui = new UIManager(this);
            this.audio = new AudioManager();
            this.playerData = new PlayerDataManager(this);
            this.animationFrameId = null;
            this.speedNoteTimeout = null;
            this.gameMode = null; // 'CLASSIC' or 'SPEED'
            this.currentSongId = null;
            this.speedModeType = null;
            this.resetGameStats();
            this.supportsVibration = 'vibrate' in navigator;
        }

        init() {
            this.ui.init();
            this.playerData.load();
            this.lang.init(); 
            this.ui.resize(document.querySelector('.game-wrapper'));
            window.addEventListener('resize', () => this.ui.resize(document.querySelector('.game-wrapper')));
            this.setupEventListeners();
            
            this.ui.updateVibrationButtons(this.playerData.playerData.vibrationMode);
            this.setInputMode(this.playerData.playerData.inputMode);

            if (!this.supportsVibration) {
                this.ui.dom.vibrationMenuButton.disabled = true;
            }
            
            this.state = 'INITIALIZED';
            this.ui.showScreen('startScreen');
        }

        setupEventListeners() {
            // Start & Menu Navigation
            this.ui.dom.startButton.addEventListener('click', () => this.startAudio());
            this.ui.dom.classicModeButton.addEventListener('click', () => this.ui.showScreen('classicMenu'));
            this.ui.dom.speedModeButton.addEventListener('click', () => this.ui.showScreen('speedMenu'));
            this.ui.dom.otherButton.addEventListener('click', () => this.ui.showScreen('otherMenu'));
            
            this.ui.dom.backButtons.forEach(btn => btn.addEventListener('click', (e) => this.ui.showScreen(e.currentTarget.dataset.target)));
            this.ui.dom.homeButtons.forEach(btn => btn.addEventListener('click', (e) => this.goHome(e.currentTarget.dataset.target)));

            // Other Menu
            this.ui.dom.playerButton.addEventListener('click', () => {
                this.ui.showScreen('playerScreen');
            });
            this.ui.dom.saveDataButton.addEventListener('click', () => {
                this.ui.dom.saveDataKey.value = '';
                this.ui.showScreen('saveDataScreen');
            });
            this.ui.dom.modeMenuButton.addEventListener('click', () => this.ui.showScreen('modePopupMenu'));
            this.ui.dom.vibrationMenuButton.addEventListener('click', () => this.ui.showScreen('vibrationPopupMenu'));
            
            // In-Game
            this.ui.dom.pauseButton.addEventListener('click', () => this.togglePause());
            this.ui.dom.resumeButton.addEventListener('click', () => this.togglePause());
            this.ui.dom.pauseRestartButton.addEventListener('click', () => this.restart());
            this.ui.dom.exitButton.addEventListener('click', () => {
                if (confirm(this.lang.get('exitConfirm'))) {
                    this.goHome('mainMenu');
                }
            });

            // Settings
            this.ui.dom.touchModeBtn.addEventListener('click', () => this.setInputMode('touch'));
            this.ui.dom.keyboardModeBtn.addEventListener('click', () => this.setInputMode('keyboard'));
            this.ui.dom.modeSwitchButton.addEventListener('click', () => this.setInputMode(this.inputMode === 'touch' ? 'keyboard' : 'touch'));
            
            this.ui.dom.vibrationButtons.forEach(btn => btn.addEventListener('click', e => {
                this.setVibrationMode(e.currentTarget.dataset.vibration);
                this.triggerVibration('hit_strong');
            }));
             this.ui.dom.vibrationHelpBtn.addEventListener('click', () => alert(this.lang.get('vibrationHelp')));

            // Save/Load
            this.ui.dom.exportSaveData.addEventListener('click', () => this.exportSaveData());
            this.ui.dom.importSaveData.addEventListener('click', () => this.importSaveData());
            
            // Input Handling
            const setupKey = (button, lane) => {
                const press = (e) => { e.preventDefault(); if (this.state === 'PLAYING') this.handleHit(lane); button.classList.add('active'); };
                const release = (e) => { e.preventDefault(); button.classList.remove('active'); };
                button.addEventListener('touchstart', press, { passive: false });
                button.addEventListener('touchend', release);
                button.addEventListener('mousedown', press);
                button.addEventListener('mouseup', release);
                button.addEventListener('mouseleave', () => button.classList.remove('active'));
            };
            this.ui.dom.keyButtons.forEach((btn, i) => setupKey(btn, i));

            window.addEventListener('keydown', e => {
                if (this.state === 'PLAYING' && this.inputMode === 'keyboard' && !e.repeat) {
                    const lane = {'a': 0, 's': 1, 'd': 2, 'f': 3}[e.key.toLowerCase()];
                    if (lane !== undefined) {
                        this.handleHit(lane);
                        this.ui.dom.keyButtons[lane].classList.add('active');
                    }
                }
                if (e.key === 'Escape' && (this.state === 'PLAYING' || this.state === 'PAUSED')) this.togglePause();
            });
            window.addEventListener('keyup', e => {
                if (this.inputMode === 'keyboard') {
                    const lane = {'a': 0, 's': 1, 'd': 2, 'f': 3}[e.key.toLowerCase()];
                    if (lane !== undefined) this.ui.dom.keyButtons[lane].classList.remove('active');
                }
            });
        }
        
        async startAudio() {
            if (this.audio.isReady) {
                this.ui.updateAllUnlocks(this.playerData.playerData);
                this.ui.showScreen('mainMenu');
                return;
            };
            try {
                await this.audio.init();
                this.state = 'READY';
                this.ui.updateAllUnlocks(this.playerData.playerData);
                this.ui.showScreen('mainMenu');
            } catch (e) {
                this.ui.dom.startButton.textContent = this.lang.get('audioError');
                this.ui.dom.startButton.disabled = true;
                alert(this.lang.get('audioError'));
            }
        }

        resetGameStats() {
            this.score = 0;
            this.combo = 0;
            this.maxCombo = 0;
            this.hitCounts = { perfect: 0, good: 0, miss: 0 };
            this.notes = [];
            this.songDuration = 0;
            this.currentBPM = 100;
            this.maxBPM = 100;
            this.lastBPMUpdateTime = 0;
            if (this.animationFrameId) {
                cancelAnimationFrame(this.animationFrameId);
                this.animationFrameId = null;
            }
            if (this.speedNoteTimeout) {
                clearTimeout(this.speedNoteTimeout);
                this.speedNoteTimeout = null;
            }
        }
        
        goHome(targetScreen) {
            this.state = 'READY';
            this.audio.stopAndReset();
            this.resetGameStats();
            this.ui.resetInGameUI();
            this.ui.draw([]);
            if (targetScreen) {
                this.ui.updateAllUnlocks(this.playerData.playerData);
                this.ui.showScreen(targetScreen);
            }
        }

        startClassicGame(songId) {
            this.audio.stopAndReset();
            this.resetGameStats();
            
            this.gameMode = 'CLASSIC';
            this.currentSongId = songId;

            const songData = SONG_LIBRARY[songId];
            this.currentBPM = songData.bpm;
            const secondsPerBeat = 60.0 / songData.bpm; 
            const beatOffset = 2; 
            this.notes = songData.beatmap.map(([beat, lane, pitch]) => {
                const hitTime = (beat - 1 + beatOffset) * secondsPerBeat;
                return { lane, pitch, hitTime, y: -100, isHit: false, isMissed: false };
            }); 
            this.songDuration = this.notes.length > 0 ? this.notes[this.notes.length - 1].hitTime + 2 : 0;
            
            this.state = 'COUNTDOWN';
            this.ui.showCountdown(3, () => this.startGame());
        }

        startSpeedGame(modeType) {
            this.audio.stopAndReset();
            this.resetGameStats();

            this.gameMode = 'SPEED';
            this.speedModeType = modeType;
            this.currentBPM = 100;
            this.maxBPM = 100;

            this.state = 'COUNTDOWN';
            this.ui.showCountdown(3, () => this.startGame());
        }

        startGame() {
            this.state = 'PLAYING';
            const vibrationCallback = this.playerData.playerData.vibrationMode.startsWith('rhythm') 
                ? () => this.triggerVibration('rhythm') 
                : null;
            this.audio.startTransport(this.currentBPM, vibrationCallback);
            
            if (this.gameMode === 'SPEED') {
                this.lastBPMUpdateTime = this.audio.getCurrentTime();
                this.scheduleNextSpeedNote();
            }
            this.animationFrameId = requestAnimationFrame(() => this.loop());
        }
        
        loop() {
            if (this.state !== 'PLAYING') return;

            const currentTime = this.audio.getCurrentTime();
            
            for (let i = this.notes.length - 1; i >= 0; i--) {
                const note = this.notes[i];
                if (!note.isHit && !note.isMissed && note.hitTime < currentTime - CONSTANTS.GOOD_THRESHOLD) {
                    note.isMissed = true;
                    this.handleJudgment('miss', note.lane);
                }
            }
            // Filter out notes that are already hit or missed.
            this.notes = this.notes.filter(note => !note.isHit && !note.isMissed);

            this.notes.forEach(note => {
                const timeUntilHit = note.hitTime - currentTime;
                note.y = this.ui.hitLineY * (1 - timeUntilHit / CONSTANTS.FALL_TIME_SECONDS);
            });

            if (this.gameMode === 'CLASSIC') {
                if (currentTime > this.songDuration && this.notes.length === 0) {
                    this.endGame();
                    return;
                }
            }
            
            if (this.gameMode === 'SPEED') {
                if (currentTime - this.lastBPMUpdateTime >= 2) { 
                    this.currentBPM *= 1.05; 
                    if (this.currentBPM > this.maxBPM) this.maxBPM = this.currentBPM; 
                    this.audio.setBPM(this.currentBPM);
                    this.lastBPMUpdateTime = currentTime; 
                }
            }
            
            this.ui.updateInGameUI({
                score: this.score,
                combo: this.combo,
                bpm: this.currentBPM,
                progress: this.gameMode === 'CLASSIC' ? (currentTime / this.songDuration) : 0,
                showProgressBar: this.gameMode === 'CLASSIC',
                showPause: true
            });
            this.ui.draw(this.notes);
            this.animationFrameId = requestAnimationFrame(() => this.loop());
        }

        handleHit(lane) {
            const currentTime = this.audio.getCurrentTime();
            let noteToHit = null;
            let bestTimeDiff = Infinity;
            
            for (const note of this.notes) {
                if (!note.isHit && !note.isMissed && note.lane === lane) {
                    const timeDiff = Math.abs(currentTime - note.hitTime);
                    if (timeDiff <= CONSTANTS.GOOD_THRESHOLD && timeDiff < bestTimeDiff) {
                        bestTimeDiff = timeDiff;
                        noteToHit = note;
                    }
                }
            }
            
            if (noteToHit) {
                noteToHit.isHit = true;
                const judgment = bestTimeDiff <= CONSTANTS.PERFECT_THRESHOLD ? 'perfect' : 'good';
                this.handleJudgment(judgment, lane, noteToHit.pitch);
            }
        }
        
        handleJudgment(type, lane, pitch) {
            if (this.state !== 'PLAYING') return;

            if (type === 'perfect' || type === 'good') {
                this.combo++;
                const multiplier = this.getComboMultiplier(this.combo);
                this.score += Math.floor((type === 'perfect' ? 100 : 50) * multiplier);
                this.hitCounts[type]++;
                this.ui.showHitFeedback(type);
                this.audio.playNote(pitch);
                this.triggerVibration('hit');
            } else if (type === 'miss') {
                this.combo = 0;
                this.hitCounts.miss++;
                this.ui.showHitFeedback('miss');
                if (this.gameMode === 'SPEED') {
                    this.endGame();
                    return;
                }
            }
            if (this.combo > this.maxCombo) this.maxCombo = this.combo;
        }
        
        endGame() {
            if (this.state !== 'PLAYING') return;
            this.state = 'GAMEOVER';
            this.audio.stopAndReset();
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
            if(this.speedNoteTimeout) clearTimeout(this.speedNoteTimeout);
            this.speedNoteTimeout = null;

            const totalNotesJudged = this.hitCounts.perfect + this.hitCounts.good + this.hitCounts.miss;
            const accuracy = totalNotesJudged > 0 ? ((this.hitCounts.perfect + this.hitCounts.good * 0.5) / totalNotesJudged) * 100 : 100;

            let results = {
                counts: this.hitCounts, score: this.score, maxCombo: this.maxCombo,
                accuracy: accuracy, expGained: 0
            };

            if (this.gameMode === 'CLASSIC') {
                let rank = 'D';
                if (accuracy >= 99) rank = 'S++'; else if (accuracy >= 98) rank = 'S+'; else if (accuracy >= 96) rank = 'S';
                else if (accuracy >= 93) rank = 'S-'; else if (accuracy >= 90) rank = 'A+'; else if (accuracy >= 85) rank = 'A';
                else if (accuracy >= 80) rank = 'A-'; else if (accuracy >= 75) rank = 'B+'; else if (accuracy >= 70) rank = 'B';
                else if (accuracy >= 65) rank = 'B-'; else if (accuracy >= 60) rank = 'C+'; else if (accuracy >= 55) rank = 'C';
                else if (accuracy >= 50) rank = 'C-';

                const rankIndex = CONSTANTS.RANK_ORDER.indexOf(rank);
                if (rankIndex >= CONSTANTS.RANK_ORDER.indexOf('S-')) results.expGained = 30; 
                else if (rankIndex >= CONSTANTS.RANK_ORDER.indexOf('A-')) results.expGained = 25; 
                else if (rankIndex >= CONSTANTS.RANK_ORDER.indexOf('B-')) results.expGained = 20; 
                else if (rankIndex >= CONSTANTS.RANK_ORDER.indexOf('C-')) results.expGained = 15; 
                else results.expGained = 8;

                results.title = this.lang.get('gameOverTitleClassic');
                results.rank = rank;
                results.achievement = this.playerData.updateClassicScore(this.currentSongId, this.score, rank, this.hitCounts);

            } else { // SPEED MODE
                results.title = this.lang.get('gameOverTitleSpeed');
                results.maxBPM = Math.floor(this.maxBPM);
                results.expGained = Math.round(this.maxCombo / 3);
                results.achievement = { text: '', class: '' };
                this.playerData.updateSpeedScore(this.speedModeType, this.maxCombo, results.maxBPM);
            }
            
            if (this.playerData.playerData.level >= CONSTANTS.MAX_LEVEL) {
                results.expGained = 0;
            }
            
            this.playerData.addExp(results.expGained);
            this.ui.showGameOver(results);
        }

        scheduleNextSpeedNote() {
            if (this.state !== 'PLAYING') return;
            const hitTime = this.audio.getCurrentTime() + CONSTANTS.FALL_TIME_SECONDS;
            const lane = this.speedModeType === 'random' ? Math.floor(Math.random() * CONSTANTS.LANE_COUNT) : 2;
            const pitch = ["C4", "E4", "G4", "C5"][lane];
            this.notes.push({ lane, pitch, hitTime, y: -100, isHit: false, isMissed: false });
            
            const secondsPerBeat = 60.0 / this.currentBPM;
            this.speedNoteTimeout = setTimeout(() => this.scheduleNextSpeedNote(), secondsPerBeat * 1000);
        }

        getComboMultiplier(combo) { if (combo >= 100) return 4.2; if (combo >= 90) return 3.9; if (combo >= 80) return 3.6; if (combo >= 70) return 3.3; if (combo >= 60) return 3.0; if (combo >= 50) return 2.7; if (combo >= 40) return 2.4; if (combo >= 30) return 2.1; if (combo >= 20) return 1.8; if (combo >= 10) return 1.5; if (combo >= 5) return 1.2; return 1.0; }
        
        togglePause() {
            if (this.state === 'PLAYING') this.pause();
            else if (this.state === 'PAUSED') this.resume();
        }

        pause() {
            if (this.state !== 'PLAYING') return;
            this.state = 'PAUSED';
            this.audio.pause();
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
            if (this.speedNoteTimeout) clearTimeout(this.speedNoteTimeout);
            this.ui.showScreen('pauseOverlay');
        }
        
        resume() {
            if (this.state !== 'PAUSED') return;
            this.state = 'PLAYING';
            this.audio.resume();
            if (this.gameMode === 'SPEED') this.scheduleNextSpeedNote();
            this.animationFrameId = requestAnimationFrame(() => this.loop());
            this.ui.showScreen('none');
        }
        
        restart() {
            if (this.state !== 'PAUSED') return;
            this.ui.showScreen('none'); // Hide pause overlay
            if (this.gameMode === 'CLASSIC') {
                this.startClassicGame(this.currentSongId);
            } else if (this.gameMode === 'SPEED') {
                this.startSpeedGame(this.speedModeType);
            }
        }

        setInputMode(mode) {
            this.inputMode = mode;
            this.playerData.playerData.inputMode = mode;
            this.playerData.save();
            this.ui.updateKeyLabels(mode);
            this.ui.updateModeButtons(mode);
        }

        setVibrationMode(mode) {
            this.vibrationMode = mode;
            this.playerData.playerData.vibrationMode = mode;
            this.playerData.save();
            this.ui.updateVibrationButtons(mode);
        }
        
        triggerVibration(type) {
            if (!this.supportsVibration || this.playerData.playerData.vibrationMode === 'off') return;
            const patterns = { hit_weak: 35, hit_strong: 70, rhythm_weak: 15, rhythm_strong: 30 };
            const currentMode = this.playerData.playerData.vibrationMode;
            if (currentMode.startsWith(type)) {
                navigator.vibrate(patterns[currentMode]);
            }
        }
        
        exportSaveData() {
            const key = this.playerData.getExportKey();
            if (key) {
                this.ui.dom.saveDataKey.value = key;
                this.ui.dom.saveDataKey.select();
                navigator.clipboard.writeText(key)
                    .then(() => alert(this.lang.get('exportSuccess')))
                    .catch(() => alert(this.lang.get('exportFail')));
            } else {
                alert('Export failed!');
            }
        }

        importSaveData() {
            const key = prompt(this.lang.get('importPrompt'));
            if (key) {
                if (this.playerData.importFromKey(key)) {
                    // After successful import, we need to update settings based on new data
                    this.lang.setLanguage(this.playerData.playerData.language || 'zh');
                    this.setVibrationMode(this.playerData.playerData.vibrationMode);
                    this.setInputMode(this.playerData.playerData.inputMode);
                    this.ui.updateAllUnlocks(this.playerData.playerData);
                    alert(this.lang.get('importSuccess'));
                    this.ui.showScreen('otherMenu');
                } else {
                    alert(this.lang.get('importFail'));
                }
            }
        }
    }

    // --- Entry Point ---
    window.addEventListener('DOMContentLoaded', () => {
        const game = new Game();
        game.init();
    });

    </script>
</body>
</html>